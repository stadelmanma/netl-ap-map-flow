      MODULE UNIT_CONVERSION_MODULE
C
C     WRITTEN BY: MATTHEW STADELMAN
C     FILE DESCRIPTION: GENERIC MODULE TO HANDLE UNIT CONVERSIONS BY
C         EITHER RETURNING A CONVERSION FACTOR OR CONVERTED VALUE. THE
C         LOWEST LEVEL ROUTINES CAN BE CALLED DIRECTLY IF THE ONLY THING
C         REQUIRED IS A CONVERSION FACTOR FROM NON-SI TO SI
C
C     DATE WRITTEN:  2016/02/17
C     LAST MODIFIED: 2017/03/05
C ----------------------------------------------------------------------
C               ---- VARIABLE DESCRIPTIONS ----
C
C ----------------------------------------------------------------------
C
C SETTING MODULE PUBLIC IF UNIT TESTING
#ifdef UNITTESTING
        PUBLIC
#else
        PRIVATE
#endif
C
C     STATICALLY DEFINED UNIT TO SI CONVERSIONS
      !
      !DISTANCE TO METERS
      REAL(8) :: MIC_MET,MM_MET,CM_MET,IN_MET,FT_MET,VOX_MET
      PARAMETER (MIC_MET = 1.0D-6, MM_MET = 1.0D-3, CM_MET = 0.01D0)
      PARAMETER (IN_MET = 0.0254D0, FT_MET = 0.3048D0)
      !
      !MASS TO KILOGRAMS
      REAL(8) :: GM_KG,LBS_KG,SLG_KG
      PARAMETER (GM_KG = 1.0D-3, LBS_KG = 0.45359237D0)
      PARAMETER (SLG_KG = 14.59390D0)
      !
      !TIME TO SECONDS
      REAL(8) :: DAY_SEC, HR_SEC, MIN_SEC
      PARAMETER (DAY_SEC = 86400.0D0, HR_SEC = 3600.0D0)
      PARAMETER (MIN_SEC = 60.0D0)
      !
      !PRESSURE TO PASCALS
      REAL(8) :: ATM_PA, BAR_PA, KPA_PA, PSI_PA
      PARAMETER (ATM_PA = 101325.0D0, BAR_PA = 1.0D5)
      PARAMETER (KPA_PA = 1.0D3, PSI_PA = 6894.757293178D0)
      !
      !VISCOSITY TO PA*S
      REAL(8) :: CP_PASEC
      PARAMETER (CP_PASEC = 1.0D-3)
      !
      ! LISTING OF SI UNITS
      CHARACTER(80),SAVE :: SI_UNITS(100)
      !
      ! PUBLIC SUBROUTINES AND VARIABLES
      PUBLIC :: VOX_MET !VOX_MET CAN VARY SO IT IS USER DEFINED
      PUBLIC :: CONVERT_VALUE, CALC_CONV_FACT
C
C
      CONTAINS
C
C     PRIMARY SUBROUTINE TO DIRECTLY CONVERT A VALUE TO DIFFERENT UNITS
      SUBROUTINE CONVERT_VALUE(UTYPE,UNIT_IN,UNIT_OUT,VALUE,BOK)
        !
        IMPLICIT NONE
        REAL(8), INTENT(OUT) :: VALUE
        CHARACTER(*), INTENT(IN) :: UTYPE, UNIT_IN
        CHARACTER(*), INTENT(OUT) :: UNIT_OUT
        LOGICAL, INTENT(IN OUT) :: BOK
        !
        REAL(8) :: CONV_FACT
        !
        CALL CALC_CONV_FACT(UTYPE,UNIT_IN,UNIT_OUT,CONV_FACT,BOK)
        IF (.NOT. BOK) GOTO 1000
        VALUE = VALUE * CONV_FACT
        !
        RETURN
        !
 1000   BOK = .FALSE.
        RETURN
        !
      END SUBROUTINE
C
C     SECONDARY SUBROUTINE TO GENERATE CONVERSION FACTORS
      SUBROUTINE CALC_CONV_FACT(UTYPE,U_STR_IN,UNIT_OUT,CONV_FACT,BOK)
        !
        USE STRING_MODULE, ONLY : UPPER_CASE
        !
        IMPLICIT NONE
        REAL(8), INTENT(OUT) :: CONV_FACT
        CHARACTER(*), INTENT(IN) :: UTYPE, U_STR_IN
        CHARACTER(*), INTENT(OUT) :: UNIT_OUT
        LOGICAL, INTENT(IN OUT) :: BOK
        !
        REAL(8) :: TMP
        INTEGER :: TYPE_ID
        CHARACTER(80) :: UNIT_IN
        !
        UNIT_IN = TRIM(U_STR_IN)
        CALL UPPER_CASE(UNIT_IN)
        CALL SET_TYPE_ID(UTYPE,TYPE_ID)
        IF (TYPE_ID < 1) GOTO 900
        !
        ! GETTING CONVERSION FACTOR
        IF (TRIM(UNIT_OUT) == 'SI') THEN
          CALL GET_CONV_FACT(TYPE_ID,UNIT_IN,CONV_FACT)
          IF (CONV_FACT < 0) GOTO 920
          UNIT_OUT = SI_UNITS(TYPE_ID)
        ELSE
          CALL GET_CONV_FACT(TYPE_ID,UNIT_IN,TMP)
          IF (TMP < 0) GOTO 920
          CALL GET_CONV_FACT(TYPE_ID,UNIT_OUT,CONV_FACT)
          IF (CONV_FACT < 0) GOTO 920
          CONV_FACT = TMP/CONV_FACT
        END IF
        !
        RETURN
        !
  900   WRITE(*,*) " NO CONVERTER FOUND FOR UNIT TYPE: "//TRIM(UTYPE)
        GOTO 1000
        !
  920   WRITE(*,2000)TRIM(UTYPE),TRIM(UNIT_IN),TRIM(UNIT_OUT)
        GOTO 1000
        !
 1000   BOK = .FALSE.
        RETURN
        !
 2000   FORMAT(1X,'NO ',A,' CONVERSION FOUND FOR ',A,' TO ',A)
        !
      END SUBROUTINE
C
C     GETS THE TYPE ID OF THE UNIT
      SUBROUTINE SET_TYPE_ID(UTYPE,TYPE_ID)
        !
        IMPLICIT NONE
        INTEGER, INTENT(OUT) :: TYPE_ID
        CHARACTER(*), INTENT(IN) :: UTYPE
        !
        IF (INDEX(UTYPE,'DIST') > 0) THEN
          TYPE_ID = 10
          SI_UNITS(TYPE_ID) = 'M'
        ELSE IF (INDEX(UTYPE,'MASS') > 0) THEN
          TYPE_ID = 20
          SI_UNITS(TYPE_ID) = 'KG'
        ELSE IF (INDEX(UTYPE,'TIME') > 0) THEN
          TYPE_ID = 30
          SI_UNITS(TYPE_ID) = 'SEC'
        ELSE IF (INDEX(UTYPE,'DENS') > 0) THEN
          TYPE_ID = 40
          SI_UNITS(TYPE_ID) = 'KG/M^3'
        ELSE IF (INDEX(UTYPE,'FLOW')+INDEX(UTYPE,'RATE') > 0) THEN
          TYPE_ID = 50
          SI_UNITS(TYPE_ID) = 'M^3/SEC'
        ELSE IF (INDEX(UTYPE,'PRES') > 0) THEN
          TYPE_ID = 60
          SI_UNITS(TYPE_ID) = 'PA'
        ELSE IF (INDEX(UTYPE,'VISC') > 0) THEN
          TYPE_ID = 70
          SI_UNITS(TYPE_ID) = 'PA*SEC'
        ELSE
          TYPE_ID = -1
        END IF
        !
        RETURN
      END SUBROUTINE
C
C     USES THE TYPE TO CALL THE PROPER UNIT CONVERTER
      SUBROUTINE GET_CONV_FACT(TYPE_ID,UNIT_IN,CONV_FACT)
        !
        IMPLICIT NONE
        REAL(8), INTENT(OUT) :: CONV_FACT
        INTEGER, INTENT(IN) :: TYPE_ID
        CHARACTER(*), INTENT(IN) :: UNIT_IN
        !
        CONV_FACT = -1.0
        !
        IF      (TYPE_ID == 10) THEN
          CALL CONV_DIST(UNIT_IN,CONV_FACT)
        ELSE IF (TYPE_ID == 20) THEN
          CALL CONV_MASS(UNIT_IN,CONV_FACT)
        ELSE IF (TYPE_ID == 30) THEN
          CALL CONV_TIME(UNIT_IN,CONV_FACT)
        ELSE IF (TYPE_ID == 40) THEN
          CALL CONV_DENS(UNIT_IN,CONV_FACT)
        ELSE IF (TYPE_ID == 50) THEN
          CALL CONV_RATE(UNIT_IN,CONV_FACT)
        ELSE IF (TYPE_ID == 60) THEN
          CALL CONV_PRES(UNIT_IN,CONV_FACT)
        ELSE IF (TYPE_ID == 70) THEN
          CALL CONV_VISC(UNIT_IN,CONV_FACT)
        ELSE
          WRITE(*,*) " NO CONVERTER FOUND FOR TYPE ID: ",TYPE_ID
        END IF
        !
      END SUBROUTINE
C
C     CONVERTS DISTANCE UNITS TO SI
      SUBROUTINE CONV_DIST(UNIT_IN,CONV_FACT)
        !
        IMPLICIT NONE
        REAL(8), INTENT(OUT) :: CONV_FACT
        CHARACTER(*), INTENT(IN) :: UNIT_IN
        !
        IF (INDEX(UNIT_IN,'MICR') > 0) THEN
          CONV_FACT = MIC_MET
        ELSEIF (INDEX(UNIT_IN,'MM') > 0) THEN
          CONV_FACT = MM_MET
        ELSEIF (INDEX(UNIT_IN,'CM') > 0) THEN
          CONV_FACT = CM_MET
        ELSEIF (INDEX(UNIT_IN,'IN') > 0) THEN
          CONV_FACT = IN_MET
        ELSEIF (INDEX(UNIT_IN,'FT')+INDEX(UNIT_IN,'FEET')> 0) THEN
          CONV_FACT = FT_MET
        ELSEIF (INDEX(UNIT_IN,'ML') > 0) THEN !USED IN RATE CONVERSION
          CONV_FACT = CM_MET
        ELSEIF (INDEX(UNIT_IN,'VOX') > 0) THEN
          CONV_FACT = VOX_MET
        ELSEIF (INDEX(TRIM(UNIT_IN),'M') > 0) THEN
          CONV_FACT = 1.0
        ELSE
          CONV_FACT = -1.0
        END IF
        !
        RETURN
      END SUBROUTINE
C
C     CONVERTS MASS UNITS TO SI
      SUBROUTINE CONV_MASS(UNIT_IN,CONV_FACT)
        !
        IMPLICIT NONE
        REAL(8), INTENT(OUT) :: CONV_FACT
        CHARACTER(*), INTENT(IN) :: UNIT_IN
        !
        IF (INDEX(UNIT_IN,'SLUG') > 0) THEN
          CONV_FACT = SLG_KG
        ELSEIF (INDEX(UNIT_IN,'LB') > 0) THEN
          CONV_FACT = LBS_KG
        ELSEIF (INDEX(UNIT_IN,'KG') > 0) THEN
          CONV_FACT = 1.0
        ELSEIF (INDEX(UNIT_IN,'G')+INDEX(UNIT_IN,'GRAM')> 0) THEN
          CONV_FACT = GM_KG
        ELSE
          CONV_FACT = -1.0
        END IF
        !
        RETURN
      END SUBROUTINE
C
C     CONVERTS TIME UNITS TO SI
      SUBROUTINE CONV_TIME(UNIT_IN,CONV_FACT)
        !
        IMPLICIT NONE
        REAL(8), INTENT(OUT) :: CONV_FACT
        CHARACTER(*), INTENT(IN) :: UNIT_IN
        !
        IF (INDEX(UNIT_IN,'DAY') > 0) THEN
          CONV_FACT = DAY_SEC
        ELSEIF (INDEX(UNIT_IN,'HOUR')+INDEX(UNIT_IN,'HR') > 0) THEN
          CONV_FACT = HR_SEC
        ELSEIF (INDEX(UNIT_IN,'MIN') > 0) THEN
          CONV_FACT = MIN_SEC
        ELSEIF (INDEX(UNIT_IN,'SEC') > 0) THEN
          CONV_FACT = 1.0
        ELSE
          CONV_FACT = -1.0
        END IF
        !
        RETURN
      END SUBROUTINE
C
C     CONVERTS DENSITY UNITS TO SI
      SUBROUTINE CONV_DENS(UNIT_IN,CONV_FACT)
        !
        IMPLICIT NONE
        REAL(8), INTENT(OUT) :: CONV_FACT
        CHARACTER(*), INTENT(IN) :: UNIT_IN
        !
        REAL(8) :: DIST_CONV, MASS_CONV
        CHARACTER(80) :: DIST_UNIT,MASS_UNIT
        !
        MASS_UNIT = UNIT_IN(1:(INDEX(UNIT_IN,'/')-1))
        DIST_UNIT = UNIT_IN((INDEX(UNIT_IN,'/')+1):LEN(UNIT_IN))
        !
        CALL CONV_MASS(MASS_UNIT,MASS_CONV)
        IF (MASS_CONV < 0) WRITE(*,2000) TRIM(MASS_UNIT)
        CALL CONV_DIST(DIST_UNIT,DIST_CONV)
        IF (DIST_CONV < 0) WRITE(*,2010) TRIM(DIST_UNIT)
        CONV_FACT = MASS_CONV/DIST_CONV**3
        !
        RETURN
        !
 2000   FORMAT(" NO DENSITY, MASS CONVERSION FOUND FOR UNIT: ",A)
 2010   FORMAT(" NO DENSITY, DISTANCE CONVERSION FOUND FOR UNIT: ",A)
        !
      END SUBROUTINE
C
C     CONVERTS FLOW RATE UNITS TO SI
      SUBROUTINE CONV_RATE(UNIT_IN,CONV_FACT)
        !
        IMPLICIT NONE
        REAL(8), INTENT(OUT) :: CONV_FACT
        CHARACTER(*), INTENT(IN) :: UNIT_IN
        !
        REAL(8) :: DIST_CONV, TIME_CONV
        CHARACTER(80) :: DIST_UNIT,TIME_UNIT
        !
        DIST_UNIT = UNIT_IN(1:(INDEX(UNIT_IN,'/')-1))
        TIME_UNIT = UNIT_IN((INDEX(UNIT_IN,'/')+1):LEN(UNIT_IN))
        !
        CALL CONV_DIST(DIST_UNIT,DIST_CONV)
        IF (DIST_CONV < 0) WRITE(*,2000) TRIM(DIST_UNIT)
        CALL CONV_TIME(TIME_UNIT,TIME_CONV)
        IF (TIME_CONV < 0) WRITE(*,2010) TRIM(TIME_UNIT)
        CONV_FACT = DIST_CONV**3/TIME_CONV
        !
        RETURN
        !
 2000   FORMAT(" NO RATE, DISTANCE CONVERSION FOUND FOR UNIT: ",A)
 2010   FORMAT(" NO RATE, TIME CONVERSION FOUND FOR UNIT: ",A)
        !
      END SUBROUTINE
C
C     CONVERTS PRESSURE UNITS TO SI
      SUBROUTINE CONV_PRES(UNIT_IN,CONV_FACT)
        !
        IMPLICIT NONE
        REAL(8), INTENT(OUT) :: CONV_FACT
        CHARACTER(*), INTENT(IN) :: UNIT_IN
        !
        IF (INDEX(UNIT_IN,'PSI') > 0) THEN
          CONV_FACT = PSI_PA
        ELSEIF(INDEX(UNIT_IN,'BAR') > 0) THEN
          CONV_FACT = BAR_PA
        ELSEIF(INDEX(UNIT_IN,'ATM') > 0) THEN
          CONV_FACT = ATM_PA
        ELSEIF(INDEX(UNIT_IN,'KPA') > 0) THEN
          CONV_FACT = KPA_PA
        ELSEIF(INDEX(TRIM(UNIT_IN),'PA') > 0) THEN
          CONV_FACT = 1.0
        ELSE
          CONV_FACT = -1.0
        END IF
        !
        RETURN
      END SUBROUTINE
C
C     CONVERTS VISCOSITY UNITS TO SI
      SUBROUTINE CONV_VISC(UNIT_IN,CONV_FACT)
        !
        IMPLICIT NONE
        REAL(8), INTENT(OUT) :: CONV_FACT
        CHARACTER(*), INTENT(IN) :: UNIT_IN
        !
        IF (INDEX(UNIT_IN,'CP')+INDEX(UNIT_IN,'CENT') > 0) THEN
          CONV_FACT = CP_PASEC
        ELSEIF (INDEX(UNIT_IN,'PA') + INDEX(UNIT_IN,'SEC') > 0) THEN
          CONV_FACT = 1.0
        ELSE
          CONV_FACT = -1.0
        END IF
        !
        RETURN
      END SUBROUTINE
C
C
      END MODULE
