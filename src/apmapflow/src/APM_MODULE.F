      MODULE APM_MODULE
C
C     WRITTEN BY: MATTHEW STADELMAN
C     FILE DESCRIPTION: STORES THE NEEDED VARIABLES AND CONSTANTS FOR
C     2-D LOCAL CUBIC LAW MODEL.
C
C     LAST MODIFIED: 2017/03/03
C ----------------------------------------------------------------------
C               ---- VARIABLE DESCRIPTIONS ----
C
C   UNIT CONVERSION VARIABLES
C     PRES_CONV,DIM_CONV,TIME_CONV, ...
C     RATE_CONV,VISC_CONV,RHO_CONV - STORES THE RESPECTIVE UNIT CONVERSION
C         FOR EACH UNIT TYPE
C     UNIT(7),UNIT_IN(7),UNIT_OUT(7) - ARRAYS TO STORE THE RESPECTIVE STRING
C         REPRESENTATION OF A UNIT TYPE
C
C   STATISTICS VARIABLES:
C     AVG_APER,APER_RMS,APER_DEV - BULK FRACTURE
C         APERTURE PROPERTIES, MIN,MAX,AVERAGE,RMS AND STANDARD DEVIATION
C     X_CORR,Z_CORR - APERTURE VARIATION CORRELATION LENGTHS HORIZONTAL
C         AND VERTICAL RESPECTIVELY
C     PERC_ARR - STORES THE USER INPUT PERCENTILE VALUES TO OUTPUT
C     NPCT - THE NUMBER OF PERCENTILES IN THE PERC_ARRY
C     PERCENTILE - BOOLEAN TO OUTPUT PERCENTILES OR NOT DURING RUNTIME
C
C   FRACTURE VARIABLES:
C     MAXDIM - THE MAXIMUM NUMBER OF GRIDBLOCKS ALONG ONE AXIS,
C         VALUES CLOSE TO THE INPUT MAP'S MAXIMUM DIMENSION
C         REDUCE EXCESS MEMORY USAGE DURING READING
C     AP_POINT_MAP - A 3-D ARRAY THAT STORES CORNER POINT VALUES
C     NX,NZ - THE APERTURE MAPS DIMENSIONS IN THE HORIZONTAL AND VERTICAL
C         DIRECTIONS RESPECTIVELY
C     DIAM,LENG - PHYSICAL DIMENSIONS OF FRACTURE, DEFINED BY MAP DIMENSIONS
C         (NX,NZ) AND USER SUPPLIED (VOXEL SIZE * MAP AVERAGING FACTOR)
C     WIDTH - A VECTOR RESPRESENTATION OF THE APERTURE MAP AFTER MASKING
C         AND ROUGHNESS HAVE BEEN APPLIED
C     DX,DZ - UNIFORMLY DEFINED TO BE 1 VOXEL, STORED AS AN ARRAY TO ALLOW
C         BASIC GRID REFINEMENT IN THE FUTURE
C     AVG_FACT - THE MAP'S HORIZONTAL AND VERTICAL AVERAGING FACTOR, NOT
C         APPLIED TO APERTURE VALUES
C     R_FACT - USER SUPPLIED ROUGHNESS REDUCTION (IN VOXELS), ACTS AS A
C         BLANKET REDUCTION OF ALL GRIDBLOCK APERTURES
C     LOW_MASK,HIGH_MASK - THE MINIMUM AND MAXIMUM APERTURE VALUES (IN VOXELS)
C         TO BE ALLOWED IN THE MODEL, OFFENDING CELLS ARE INCREASING OR REDUCED ACCORDINGLY
C
C   PRESSURE/FLOW VARIABLES:
C     TRX,TRZ - HORIZONTAL AND VERTICAL GRID BLOCK TRANSMISSIBLITY ARRAYS,
C         DEFINED AT LEFT AND TOP FACES OF A GRIDBLOCK RESPECTIVELY.
C     FRAC_PR - FRACTURE PRESSURE MAP RESPECTIVELY
C     RATEC,PRESC - BOOLEANS STATING IF THE FRACTURE IS CONTROLLED WITH
C         A FLOW RATE OR PRESSURE BOUNDARY CONDITION
C     INLPB - THE INLET FRACTURE PRESSURE
C     OUTPB - THE FACTURE'S OUTLET PRESSURE AND PESDUO-PRESSURE
C     INJRATE - STORES THE FRACTURE INLET FLOW RATE OUNDARY CONDITION VALUE
C     OUTRATE - STORES THE FRACTURE OUTLET FLOW RATE BOUNDARY CONDITION VALUE
C     INLET - STORES THE INDICIES OF GRIDBLOCKS AT THE INLET FACE
C     OUTLET - STORES THE INDICIES OF GRIDBLOCKS AT THE OUTLET FACE
C     OUTLET_SIDE - STORES WHAT SIDE OF THE FRACTURE IS OPEN TO FLUID FLOWING OUT OF IT,
C         OPPOSITE SIDE IS THE INLET BOUNDARY, OTHER 2 SIDES ARE NO-FLOW BOUNARIES
C     NC - STORES THE NUMBER OF INLET/OUTLET FACES
C
C   FLUID PROPERTIES:
C     AVG_VISC - AVERAGE VISCOSITY OF THE FRACTURE USED IN LIQUID SIMULATIONS
C     RHO - USER SUPPLIED DENSITY OF THE FLUID, ONLY USED TO CALCULATE REYNOLDS NUMBER
C
C   LCL MODEL VARIABLE DEFAULTS DEFINED IN SUBROUTINE: INITIALIZE_RUN
C
C ---------------------------------------------------------------------
C
      USE STRING_MODULE, ONLY : MAXLEN
      PUBLIC
C
C     UNIT CONVERSION VARIABLES
      ! VARIABLES TO STORE RESPECTIVE CONVERSION FACTORS
      REAL(8), SAVE :: PRES_CONV, DIM_CONV, TIME_CONV, RATE_CONV
      REAL(8), SAVE :: VISC_CONV, RHO_CONV
      ! VARIABLES TO STORE THE STRING REPRESENTATION OF EACH UNIT
      CHARACTER(MAXLEN), SAVE :: UNIT(7), UNIT_IN(7), UNIT_OUT(7)
C
C     STATISTICS VARIABLES
      REAL(8), ALLOCATABLE, SAVE :: PERC_ARR(:,:)
      REAL(8), SAVE :: APER_RMS, APER_DEV, X_CORR, Z_CORR
      INTEGER, SAVE :: NPCT
      LOGICAL, SAVE :: PERCENTILE
C
C     FRACTURE VARAIBLES
      REAL(8), ALLOCATABLE, SAVE :: WIDTH(:), DX(:), DZ(:)
      REAL(8), ALLOCATABLE, SAVE :: AP_POINT_MAP(:, :, :)
      REAL(8), ALLOCATABLE, SAVE :: FRAC_PR(:,:)
      REAL(8), ALLOCATABLE, SAVE :: TRX(:,:), TRZ(:,:), Q(:,:)
      REAL(8), SAVE :: DIAM, LENG, AVG_APER, AVG_FACT, AVG_VISC
      REAL(8), SAVE :: R_FACT, HIGH_MASK, LOW_MASK
      REAL(8), SAVE :: INLPB, OUTPB, OUTRATE, INJRATE, RHO
      INTEGER, ALLOCATABLE, SAVE :: INLET(:), OUTLET(:)
      INTEGER, SAVE :: MAXDIM, NX, NZ, NC
      LOGICAL, SAVE :: RATEC, PRESC
      CHARACTER(MAXLEN), SAVE :: OUTLET_SIDE, INLET_SIDE
C
C
      CONTAINS
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE ALLOCATE_FRAC(NX, NZ)
      !
      ! SETS UP VECTORS AND ARRAYS FOR THE FRACTURE PROPERTIES
      !
      IMPLICIT NONE
      INTEGER, INTENT(IN) :: NX, NZ
      INTEGER :: N
      N = 5
      !
      ALLOCATE(AP_POINT_MAP(NZ, NX, 4))
      ALLOCATE(WIDTH(NX*NZ), DX(NX*NZ), DZ(NX*NZ))
      ALLOCATE(TRX(1:NZ, 0:NX), TRZ(0:NZ, 1:NX))
      ALLOCATE(INLET(MAX(NX, NZ)), OUTLET(MAX(NX, NZ)))
      ALLOCATE(FRAC_PR(0:NZ+1, 0:NX+1), Q(N, NX*NZ))
      !
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE DEALLOCATE_FRAC
      !
      DEALLOCATE(AP_POINT_MAP, WIDTH, DX, DZ)
      DEALLOCATE(TRX, TRZ, INLET, OUTLET)
      DEALLOCATE(FRAC_PR, Q, PERC_ARR)
      !
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE COEF
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     DATE WRITTEN:  2015/03/02
C     LAST MODIFIED: 2017/03/03
C
C     PROGRAM DESCRIPTION: INIITIALIZES ALL OF THE SIMULATION COEFFICENTS
C
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       PH,PL - PRESSURE INTERPOLATION VARIABLES
C       B - APERTURE OF THE INTERFACE BEING CORRECTED
C       DBP - HALF OF THE DELTA X FROM THE "P" SIDE
C       DBF - HALF OF THE DELTA X FROM THE "F" SIDE
C       THETA - SLOPE ANGLE FROM CENTER OF CELL TO INTERFACE
C       BP3 - TAPERED PLATE CORRECTED "P" APERTURE CUBED
C       BF3 - TAPERED PLATE CORRECTED "F" APERTURE CUBED
C       BOK - CONTROL VARIABLE USED TO HALT PROGRAM IF A FATAL ERROR IS ENCOUNTERED
C
C ----------------------------------------------------------------------
C
      USE UNIT_CONVERSION_MODULE, ONLY : VOX_MET
      IMPLICIT NONE
      !
      REAL(8) :: RHT_FACE(NX*NZ), TOP_FACE(NX*NZ)
      REAL(8) :: B,BF3,BP3,DBF,DBP,W3,THETA
      INTEGER :: I,IX,IZ
C
C     INTIALIZING VARIABLES
      DX(:) = DIAM/NX
      DZ(:) = LENG/NZ
      TRX(:,:) = 0.0
      TRZ(:,:) = 0.0
C
C     CALCULATING THE AVERAGE APERTURE AT CELL FACES
      DO IZ = 1,NZ
        DO IX = 1,NX
          I = (IZ - 1) * NX + IX
          RHT_FACE(I) = AP_POINT_MAP(IZ,IX,2) + AP_POINT_MAP(IZ,IX,3)
          TOP_FACE(I) = AP_POINT_MAP(IZ,IX,4) + AP_POINT_MAP(IZ,IX,3)
        END DO
      END DO
      RHT_FACE = 0.5 * RHT_FACE - R_FACT
      TOP_FACE = 0.5 * TOP_FACE - R_FACT
      WHERE (RHT_FACE < LOW_MASK) RHT_FACE = LOW_MASK
      WHERE (TOP_FACE < LOW_MASK) TOP_FACE = LOW_MASK
      RHT_FACE = RHT_FACE * VOX_MET
      TOP_FACE = TOP_FACE * VOX_MET
C
C     USING THE STOKES TAPERED PLATE FLOW SOLUTION TO CALCULATE THE TRANS
C     OF THE RIGHT AND TOP INTERFACE OF A GRID BLOCK
      DO IZ = 1,NZ
        DO IX = 1,NX-1
          I = (IZ-1)*NX + IX
          !
          ! SOLVING TAPERED PLATE CORRECTION FOR CELL CENTERS TO INTERFACE
          B = RHT_FACE(I) !WIDTH AT INTERFACE BASED ON CORNER VALUES
          DBP = DX(I)/2  !(DX(I)/2 = DISTANCE FROM CENTER CELL TO INTERFACE IF PLANAR
          THETA = ATAN(ABS(WIDTH(I)-B)/DBP)
          W3 = (2 * WIDTH(I)**2 * B**2)/(WIDTH(I) + B)
          BP3 = W3 * 3*(TAN(THETA) - THETA)/(TAN(THETA)**3)
          IF (INT(1E9*(TAN(THETA) - THETA)) == 0) BP3 = W3
          !
          DBF = DX(I+1)/2  !(DX(I+1)/2 = DISTANCE FROM CENTER CELL TO INTERFACE IF PLANAR
          THETA = ATAN(ABS(B-WIDTH(I+1))/DBF)
          W3 = (2 * B**2 * WIDTH(I+1)**2)/(B + WIDTH(I+1))
          BF3 = W3 * 3*(TAN(THETA) - THETA)/(TAN(THETA)**3)
          IF (INT(1E9*(TAN(THETA) - THETA)) == 0) BF3 = W3
          !
          TRX(IZ,IX) = (DBP/BP3 + DBP/BF3)**(-1) * (DZ(I)/12)
        END DO
      END DO
C
      DO IZ = 1,NZ-1
        DO IX = 1,NX
          I = (IZ-1)*NX + IX
          !
          ! SOLVING TAPERED PLATE CORRECTION FOR CELL CENTERS TO INTERFACE
          B = TOP_FACE(I) !WIDTH AT INTERFACE BASED ON CORNER VALUES
          DBP = DZ(I)/2  !(DZ(I)/2 = DISTANCE FROM CENTER CELL TO INTERFACE IF PLANAR
          THETA = ATAN(ABS(WIDTH(I)-B)/DBP)
          W3 = (2 * WIDTH(I)**2 * B**2)/(WIDTH(I) + B)
          BP3 = W3 * 3*(TAN(THETA) - THETA)/(TAN(THETA)**3)
          IF (INT(1E9*(TAN(THETA) - THETA)) == 0) BP3 = W3
          !
          DBF = DZ(I+NX)/2  !(DZ(I+NX)/2 = DISTANCE FROM CENTER CELL TO INTERFACE IF PLANAR
          THETA = ATAN(ABS(B-WIDTH(I+NX))/DBF)
          W3 = (2 * B**2 * WIDTH(I+NX)**2)/(B + WIDTH(I+NX))
          BF3 = W3 * 3*(TAN(THETA) - THETA)/(TAN(THETA)**3)
          IF (INT(1E9*(TAN(THETA) - THETA)) == 0) BF3 = W3
          !
          TRZ(IZ,IX) = (DBP/BP3 + DBP/BF3)**(-1) * (DX(I)/12)
        END DO
      END DO
C
C     HANDLING SPECIAL CASE AT RIGHT SIDE OF FRACTURE
      DO IZ = 1,NZ
        I = (IZ-1)*NX + NX
        B = RHT_FACE(I) !WIDTH AT INTERFACE BASED ON CORNER VALUES
        DBP = DX(I)/2  !(DX(I)/2 = DISTANCE FROM CENTER CELL TO INTERFACE IF PLANAR
        THETA = ATAN(ABS(WIDTH(I)-B)/DBP)
        W3 = (2 * WIDTH(I)**2 * B**2)/(WIDTH(I) + B)
        BP3 = W3 * 3*(TAN(THETA) - THETA)/(TAN(THETA)**3)
        IF (INT(1E9*(TAN(THETA) - THETA)) == 0) BP3 = W3
        !
        TRX(IZ,NX) = (DZ(I)*BP3)/(12.0*DX(I))
      END DO
C
C     HANDLING SPECIAL CASE AT TOP OF FRACTURE
      DO IX = 1,NX
        I = (NZ-1)*NX + IX
        B = TOP_FACE(I) !WIDTH AT INTERFACE BASED ON CORNER VALUES
        DBP = DZ(I)/2  !(DZ(I)/2 = DISTANCE FROM CENTER CELL TO INTERFACE IF PLANAR
        THETA = ATAN(ABS(WIDTH(I)-B)/DBP)
        W3 = (2 * WIDTH(I)**2 * B**2)/(WIDTH(I) + B)
        BP3 = W3 * 3*(TAN(THETA) - THETA)/(TAN(THETA)**3)
        IF (INT(1E9*(TAN(THETA) - THETA)) == 0) BP3 = W3
        !
        TRZ(NZ,IX) = (DZ(I)*BP3)/(12.0*DX(I))
      END DO
C
C     DIVIDING TRANSMISSIVITY BY VISCOSITY
      TRX(:,:) = TRX(:,:)/AVG_VISC
      TRZ(:,:) = TRZ(:,:)/AVG_VISC
C
      RETURN
C
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE FLOW_BOUNDARY(BOK)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     DATE WRITTEN:  2015/03/02
C     LAST MODIFIED: 2016/07/08
C
C     PROGRAM DESCRIPTION: DEFINES FLOW AND PRESSURE BOUNDARY CONIDITIONS
C
C     SUBROUTINE CALLS: NONE
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       BOK - CONTROL VARIABLE USED TO HALT PROGRAM IF A FATAL ERROR IS ENCOUNTERED
C
C ----------------------------------------------------------------------
C
      USE IO_MODULE, ONLY : BLANK, MESSAGE
C
      IMPLICIT NONE
      LOGICAL, INTENT(IN OUT) :: BOK
      !
      INTEGER :: IX,IZ
C
C
      CALL BLANK
      CALL MESSAGE(" DEFINING BOUNDARY CELL TRANSMISSIBILIES")
C
C     HANDLING EACH OUTFLOW SIDE CASE
      IF (INDEX(OUTLET_SIDE,'LEFT') > 0) THEN
C
C       DEFINING THE BOUNDARY CONDITIONS FOR EACH SIDE OF THE FRACTURE
        TRX(1:NZ,0) = 2*TRX(1:NZ,1) !LEFT SIDE BOUNDARY
        TRX(1:NZ,NX) = 2*TRX(1:NZ,NX) !RIGHT SIDE BOUNDARY
        TRZ(0,1:NX) = 0.0 !BOTTOM BOUNDARY
        TRZ(NZ,1:NX) = 0.0 !EXTRA TOP ROW
C
C       DEFINING INLET AND OUTLET
        INLET_SIDE = 'RIGHT'
        NC = NZ
        DO IZ = 1,NZ
          INLET(IZ) = (IZ-1)*NX + NX
          OUTLET(IZ) = (IZ-1)*NX + 1
        END DO
      ELSE IF (INDEX(OUTLET_SIDE,'RIGHT') > 0) THEN
C
C       DEFINING THE BOUNDARY CONDITIONS FOR EACH SIDE OF THE FRACTURE
        TRX(1:NZ,0) = 2*TRX(1:NZ,1) !LEFT SIDE BOUNDARY
        TRX(1:NZ,NX) = 2*TRX(1:NZ,NX) !RIGHT SIDE BOUNDARY
        TRZ(0,1:NX) = 0.0 !BOTTOM BOUNDARY
        TRZ(NZ,1:NX) = 0.0 !EXTRA TOP ROW
C
C       DEFINING INLET AND OUTLET
        INLET_SIDE = 'LEFT'
        NC = NZ
        DO IZ = 1,NZ
          INLET(IZ) = (IZ-1)*NX + 1
          OUTLET(IZ) = (IZ-1)*NX + NX
        END DO
      ELSE IF (INDEX(OUTLET_SIDE,'TOP') > 0) THEN
C
C       DEFINING THE BOUNDARY CONDITIONS FOR EACH SIDE OF THE FRACTURE
        TRX(1:NZ,0) = 0.0 !LEFT SIDE BOUNDARY
        TRX(1:NZ,NX) = 0.0 !RIGHT SIDE BOUNDARY
        TRZ(0,1:NX) = 2*TRZ(1,1:NX) !BOTTOM BOUNDARY
        TRZ(NZ,1:NX) = 2*TRZ(NZ,1:NX) !EXTRA TOP ROW
C
C       DEFINING INLET AND OUTLET
        INLET_SIDE = 'BOTTOM'
        NC = NX
        DO IX = 1,NX
          INLET(IX) = IX
          OUTLET(IX) = (NZ-1)*NX + IX
        END DO
      ELSE IF (INDEX(OUTLET_SIDE,'BOTTOM') > 0) THEN
C
C       DEFINING THE BOUNDARY CONDITIONS FOR EACH SIDE OF THE FRACTURE
        TRX(1:NZ,0) = 0.0 !LEFT SIDE BOUNDARY
        TRX(1:NZ,NX) = 0.0 !RIGHT SIDE BOUNDARY
        TRZ(0,1:NX) = 2*TRZ(1,1:NX) !BOTTOM BOUNDARY
        TRZ(NZ,1:NX) = 2*TRZ(NZ,1:NX) !EXTRA TOP ROW
C
C       DEFINING INLET AND OUTLET
        INLET_SIDE = 'TOP'
        NC = NX
        DO IX = 1,NX
          INLET(IX) = (NZ-1)*NX + IX
          OUTLET(IX) = IX
        END DO
      ELSE
        GOTO 1000
      END IF
C
      RETURN
C
 1000 BOK = .FALSE.
      CALL MESSAGE(" INVALID OUTLET SIDE ENTERED: "//TRIM(OUTLET_SIDE))
      RETURN
C
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE WRITE_VTK_DATA(IUNIT, FNAME, UNIT, DTYPE, DATA_ARR)
        !
        ! ACTS AS AN INTEFACE TO SIMPLIFY CALLING WRITE_VTK_DATA
        !
        USE OUTPUT_MODULE, ONLY : WRITE_DATA => WRITE_VTK_DATA
        IMPLICIT NONE
        !
        REAL(8), INTENT(IN) :: DATA_ARR(:)
        INTEGER, INTENT(IN) :: IUNIT
        CHARACTER(*), INTENT(IN) :: FNAME, UNIT, DTYPE
        !
        CALL WRITE_DATA(IUNIT, FNAME, UNIT, DTYPE, DATA_ARR, NX, NZ)
        !
        RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      END MODULE
