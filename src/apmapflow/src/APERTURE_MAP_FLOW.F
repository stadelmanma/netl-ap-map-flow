      PROGRAM APERTURE_MAP_FLOW
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     PROGRAM DESCRIPTON: RUNS THE LOCAL CUBIC LAW MODEL ON A SUPPLIED
C         FRACTURE APERTURE MAP OUTPUTTING THE DATA TO MULTIPLE CSV FILES
C         AND A VTK FILE FOR USE WITH PARAVIEW. THIS PROGRAM WAS DESIGNED
C         UNDER AN ORISE APPOINTMENT AT THE NATIONAL ENERGY TECHNOLOGY LAB
C         IN MORGANTOWN WEST VIRGINIA.
C
C     DATE WRITTEN:  2016/02/12
C     LAST MODIFIED: 2016/07/10
C
C     SUBROUTINE CALLS: INITIALIZE_RUN, FRAC_FLOW, OUTPUT_DATA, CLOSE_IO
C
C ---------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       BOK - CONTROL VARIABLE USED TO HALT PROGRAM IF A FATAL ERROR IS ENCOUNTERED
C
C ----------------------------------------------------------------------
C
      USE APM_MODULE
      USE IO_MODULE, ONLY : BLANK, MESSAGE, CLOSE_IO
C
      IMPLICIT NONE
      LOGICAL :: BOK = .TRUE.
C
C     INITIALIZING THE MODEL
      CALL INITIALIZE_RUN(BOK)
      IF (.NOT. BOK) GOTO 1000
C
C     RUNNING SUBROUTINE TO SOLVE FOR FLOW
      CALL BLANK
      CALL MESSAGE(" CALCULATING FLOW THROUGH FRACTURE")
C
C     SOLVING FOR FLOW THROUGH FRACTURE
      CALL FRAC_FLOW()
      CALL BLANK
      CALL MESSAGE("      FRACTURE FLOWS CALCULATED")
C
C     CALCULATING AND WRITTING OUTPUT DATA
      CALL OUTPUT_DATA(BOK)
C
C     CLOSING OUTPUT FILES
      CALL CLOSE_IO
C
 1000 WRITE(*,"(1X)")
      WRITE(*,"('     **** EXITING PROGRAM ****')")
      IF (.NOT. BOK) STOP(1)
C
      END PROGRAM
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE INITIALIZE_RUN(BOK)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     PROGRAM DESCRIPTION: CONTROLS CALLING OF THE MODEL INITALIZATION
C     ROUTINES AND SETS DEFAULT MODEL PARAMETERS.
C
C     SUBROUTINE CALLS: ASSIGN_IO, READ_MASTER, READ_AP_MAP,
C                       COEF, FLOW_BOUNDARY, INIT_OUTPUT
C
C     LAST MODIFIED: 2017/02/08
C
C ---------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       BOK - CONTROL VARIABLE USED TO HALT PROGRAM IF A FATAL ERROR IS ENCOUNTERED
C
C ---------------------------------------------------------------------
C
      USE APM_MODULE
      USE IO_MODULE, ONLY : IINP, IAPM, IOUT, OPEN_IO, MESSAGE
      USE STRING_MODULE, ONLY : MAXLEN
      USE UNIT_CONVERSION_MODULE, ONLY : VOX_MET, CALC_CONV_FACT
C
      IMPLICIT NONE
      LOGICAL, INTENT(IN OUT) :: BOK
      !
      CHARACTER(MAXLEN) :: CVAR
C
C     DEFAULT VALUES
C
      ! SETTING TO STDOUT INITIALLY
      IOUT = 6
      ! DEFAULT PERCENTILE SETTINGS
      PERCENTILE = .FALSE.
      NPCT = 9
      ALLOCATE(PERC_ARR(2, NPCT))
      PERC_ARR(1, 1:9) = [1, 5, 10, 25, 50, 75, 90, 95, 99]
      ! DEFAULT TO PRESSURE BOUNDARY CONDITION
      RATEC = .FALSE.
      PRESC = .FALSE.
      INLPB = -1.0
      OUTPB = -1.0
      OUTRATE = -1.0
      INJRATE = -1.0
      ! DEFAULT LIQUID PROPERIES
      RHO = 1.0
      AVG_VISC = -1.0
      ! DEFAULT APERTURE MAP PROPERTIES
      MAXDIM = 2000
      AVG_FACT = 1.0
      R_FACT = 0.0
      VOX_MET = 1.0
      HIGH_MASK = 1E6
      LOW_MASK = 1E-6
      OUTLET_SIDE = 'TOP'
      UNIT(:) = 'SI'
      UNIT_IN(1) = 'PA'
      UNIT_IN(2) = 'M'
      UNIT_IN(3) = 'K'
      UNIT_IN(4) = 'SEC'
      UNIT_IN(5) = 'M^3/SEC'
      UNIT_IN(6) = 'PA*SEC'
      UNIT_IN(7) = 'KG/M^3'
      UNIT_OUT(1) = 'PA'
      UNIT_OUT(2) = 'M'
      UNIT_OUT(3) = 'K'
      UNIT_OUT(4) = 'SEC'
      UNIT_OUT(5) = 'M^3/SEC'
      UNIT_OUT(6) = 'PA*SEC'
      UNIT_OUT(7) = 'KG/M^3'
C
C     INITIALIZING IO
      CALL OPEN_IO(BOK)
      IF (.NOT. BOK) GOTO 1000
C
C     READING INPUT FILE
      CALL READ_MASTER(IINP, BOK)
      IF (.NOT. BOK) GOTO 1000
C
C     CHECKING IF BOTH INLET AND OUTLET PRESSURE CONDITION WERE SUPPLIED
      IF ((INLPB .GE. 0) .AND. (OUTPB .GE. 0)) THEN
        PRESC = .TRUE.
        CALL MESSAGE("     FRACTURE FLOW IS PRESSURE CONTROLLED")
      ELSE
        PRESC = .FALSE.
        CALL MESSAGE("     FRACTURE FLOW IS RATE CONTROLLED")
      END IF
C
C     CHECKING VISCOSITY VALUE PROVIDED
      IF (AVG_VISC > 0) THEN
        WRITE(CVAR, 2000) AVG_VISC/VISC_CONV, TRIM(UNIT_IN(6))
        CALL MESSAGE(CVAR)
      ELSE
        WRITE(CVAR, 2010) AVG_VISC/VISC_CONV
        CALL MESSAGE(CVAR)
        GOTO 1000
      END IF
C
C     SETTING CONVERSION VALUES
      CALL CALC_CONV_FACT('PRES', UNIT_IN(1), UNIT(1), PRES_CONV,BOK)
      CALL CALC_CONV_FACT('DIST', UNIT_IN(2), UNIT(2), DIM_CONV,BOK)
      CALL CALC_CONV_FACT('TIME', UNIT_IN(4), UNIT(4), TIME_CONV,BOK)
      CALL CALC_CONV_FACT('RATE', UNIT_IN(5), UNIT(5), RATE_CONV,BOK)
      CALL CALC_CONV_FACT('VISC', UNIT_IN(6), UNIT(6), VISC_CONV,BOK)
      CALL CALC_CONV_FACT('DENS', UNIT_IN(7), UNIT(7), RHO_CONV,BOK)
      IF (.NOT. BOK) GOTO 1000
C
C     READING APERTURE MAP
      CALL READ_AP_MAP(IAPM, BOK)
      IF (.NOT. BOK) GOTO 1000
C
C     INITIALIZING FRACTURE PROPERTIES
      CALL COEF
C
C     CREATING FLOW AND PRESSURE BOUNDARIES
      CALL FLOW_BOUNDARY(BOK)
      IF (.NOT. BOK) GOTO 1000
C
      RETURN
C
C
 1000 BOK = .FALSE.
C
 2000 FORMAT(5X, 'AVERAGE LIQUID VISCOSITY USED ', G12.6,1X,A)
C
 2010 FORMAT(1X, 'ERROR - NONE OR INVAILD VISCOSITY PROVIDED ', G15.6)
C
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE READ_MASTER(IUNIT, BOK)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     PROGRAM DESCRIPTION: READS THE INITIALIZATION FILE
C
C     LAST MODIFIED: 2016/03/07
C
C     SUBROUTINE CALLS: LNPROC, UNIT_CONV
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       NFLD - NUMBER OF FIELDS IN CFLD AND LFLD AFTER A PROCESSING A LINE
C       OUTPUT_UNIT - BOOLEAN STATING IF OUTPUT UNITS HAVE BEEN DEFINED
C       BOK - CONTROL VARIABLE USED TO HALT PROGRAM IF A FATAL ERROR IS ENCOUNTERED
C
C ----------------------------------------------------------------------
C
      USE APM_MODULE
      USE IO_MODULE, ONLY : MESSAGE, INSUFFICIENT_ERROR, FIELD_ERROR
      USE STRING_MODULE, ONLY : MAXFLD, MAXLEN, LNPROC, UPPER_CASE
      USE UNIT_CONVERSION_MODULE, ONLY : VOX_MET,
     &                                   CONVERT_VALUE, CALC_CONV_FACT
C
      IMPLICIT NONE
      INTEGER, INTENT(IN) :: IUNIT
      LOGICAL, INTENT(IN OUT) :: BOK
      !
      REAL(8) :: TMP
      INTEGER :: IFLD, NFLD, LFLD(MAXFLD)
      LOGICAL :: OUTPUT_UNIT = .FALSE.
      CHARACTER(MAXLEN) :: CVAR, CFLD(MAXFLD), TMP_UNIT
C
C     READING IN MASTER INPUT FILE
      CALL LNPROC(IUNIT, MAXFLD, MAXLEN, CVAR, CFLD, LFLD, NFLD, 'SAME')
      DO WHILE (NFLD > 0)
        !
        ! CONVERT KEYWORD FIELD TO UPPER CASE FOR CONSISTENT MATCHING
        CALL UPPER_CASE(CFLD(1))
        ! DEPRECATED KEYWORDS
        ! READING INITAL FRACTURE PRESSURE
        IF (INDEX(CFLD(1), 'FRAC-PRESS') > 0) THEN
          CALL MESSAGE("NOTICE - KEYWORD 'FRAC-PRESS' IS DEPRECATED")
          IF (NFLD < 3) GOTO 905
          IFLD = 2
          READ(CFLD(IFLD), "(F100.0)", ERR = 910) INLPB
          IFLD = 3
          READ(CFLD(IFLD), "(A)", ERR = 910) UNIT_IN(1)
          CALL CONVERT_VALUE('PRES', UNIT_IN(1), UNIT(1), INLPB, BOK)
        ! READING OUTFLOW SIDE
        ELSEIF (INDEX(CFLD(1), 'OUTFLOW-SIDE') > 0) THEN
          CALL MESSAGE("NOTICE - KEYWORD 'OUTFLOW-SIDE' IS DEPRECATED")
          IFLD = 2
          IF (NFLD < IFLD) GOTO 905
          OUTLET_SIDE = CFLD(IFLD)
        !
        ! READING INLET PRESSURE
        ELSEIF (INDEX(CFLD(1), 'INLET-PRESS') > 0) THEN
          IF (NFLD < 3) GOTO 905
          IFLD = 2
          READ(CFLD(IFLD), "(F100.0)", ERR = 910) INLPB
          IFLD = 3
          READ(CFLD(IFLD), "(A)", ERR = 910) UNIT_IN(1)
          CALL CONVERT_VALUE('PRES', UNIT_IN(1), UNIT(1), INLPB, BOK)
        ! READING OUTLET PRESSURE
        ELSEIF (INDEX(CFLD(1), 'OUTLET-PRES') > 0) THEN
          IF (NFLD < 3) GOTO 905
          IFLD = 2
          READ(CFLD(IFLD), "(F100.0)", ERR = 910) OUTPB
          IFLD = 3
          READ(CFLD(IFLD), "(A)", ERR = 910) UNIT_IN(1)
          CALL CONVERT_VALUE('PRES', UNIT_IN(1), UNIT(1), OUTPB, BOK)
        ! READING OUTLET FLOW RATE
        ELSEIF (INDEX(CFLD(1), 'OUTLET-RATE') > 0) THEN
          IF (NFLD < 3) GOTO 905
          IFLD = 2
          READ(CFLD(IFLD), "(F100.0)", ERR = 910) OUTRATE
          IFLD = 3
          READ(CFLD(IFLD), "(A)", ERR = 910) UNIT_IN(5)
          RATEC = .TRUE.
          CALL CONVERT_VALUE('RATE', UNIT_IN(5), UNIT(5), OUTRATE, BOK)
        ELSEIF (INDEX(CFLD(1), 'INLET-RATE') > 0) THEN
          IF (NFLD < 3) GOTO 905
          IFLD = 2
          READ(CFLD(IFLD), "(F100.0)", ERR = 910) INJRATE
          IFLD = 3
          READ(CFLD(IFLD), "(A)", ERR = 910) UNIT_IN(5)
          RATEC = .TRUE.
          CALL CONVERT_VALUE('RATE', UNIT_IN(5), UNIT(5), INJRATE, BOK)
        ! READING FLUID DENSITY
        ELSEIF (INDEX(CFLD(1), 'FLUID-DENSITY') > 0) THEN
          IFLD = 2
          IF (NFLD < IFLD) GOTO 905
          READ(CFLD(IFLD), "(F100.0)", ERR = 910) RHO
          IFLD = 3
          READ(CFLD(IFLD), "(A)", ERR = 910) UNIT_IN(7)
          CALL CONVERT_VALUE('DENS', UNIT_IN(7), UNIT(7), RHO, BOK)
        ! READING FLUID VISCOSITY
        ELSEIF (INDEX(CFLD(1), 'FLUID-VISCOSITY') > 0) THEN
          IFLD = 2
          IF (NFLD < IFLD) GOTO 905
          READ(CFLD(IFLD), "(F100.0)", ERR = 910) AVG_VISC
          IFLD = 3
          READ(CFLD(IFLD), "(A)", ERR = 910) UNIT_IN(6)
          CALL CALC_CONV_FACT('VISC',UNIT_IN(6),UNIT(6),VISC_CONV,BOK)
          CALL CONVERT_VALUE('VISC', UNIT_IN(6), UNIT(6), AVG_VISC, BOK)
        ! READING OUTLET SIDE
        ELSEIF (INDEX(CFLD(1), 'OUTLET-SIDE') > 0) THEN
          IFLD = 2
          IF (NFLD < IFLD) GOTO 905
          CALL UPPER_CASE(CFLD(IFLD))
          OUTLET_SIDE = CFLD(IFLD)
        ! READING VOXEL SIZE
        ELSEIF (INDEX(CFLD(1), 'VOXEL') > 0) THEN
          IFLD = 3
          IF (NFLD < 4) GOTO 905
          READ(CFLD(IFLD), "(F10.0)", ERR = 910) VOX_MET
          CFLD(5) = 'SI'
          CALL CONVERT_VALUE('DIST', CFLD(4), UNIT(2), VOX_MET, BOK)
        ! READING ROUGHNESS COEFFICIENT TO APPLY
        ELSEIF (INDEX(CFLD(1), 'ROUGH') > 0) THEN
          IFLD  = 3
          IF (NFLD < IFLD) GOTO 905
          READ(CFLD(IFLD), "(F10.0)", ERR = 910) R_FACT
        ! READING MAP AVERAGING FACTOR
        ELSEIF (INDEX(CFLD(1), 'MAP') > 0) THEN
          IFLD = 4
          IF (NFLD < IFLD) GOTO 905
          READ(CFLD(IFLD), "(F10.0)", ERR = 910) AVG_FACT
        ! READING IF TO OUTPUT PERCENTILES OF DATA
        ELSEIF (INDEX(CFLD(1), 'CALCULATE') > 0) THEN
          IFLD = 2
          IF (NFLD < IFLD) GOTO 905
          CALL UPPER_CASE(CFLD(IFLD))
          IF (INDEX(CFLD(IFLD), 'PERCENT') > 0) PERCENTILE = .TRUE.
          ! POPULATING PERCENTILE ARRAY
          IF (NFLD >= 3) THEN
            ! REALLOCATING PERCENTILE ARRAY FROM DEFAULT SETTINGS
            DEALLOCATE(PERC_ARR)
            ALLOCATE(PERC_ARR(2, NFLD - 2))
            PERC_ARR(:, :) = 0
            NPCT = NFLD - 2
            DO IFLD = 3, NFLD
              READ(CFLD(IFLD), "(F10.0)", ERR = 910)PERC_ARR(1, IFLD-2)
            END DO
          END IF
        ! READING HIGH MASK TO APPLY TO FRACTURE
        ELSEIF (INDEX(CFLD(1), 'HIGH-MASK') > 0) THEN
          IFLD = 2
          IF (NFLD < 2) GOTO 905
          READ(CFLD(IFLD), *, ERR = 910) HIGH_MASK
        ! READING LOW MASK TO APPLY TO FRACTURE
        ELSEIF (INDEX(CFLD(1), 'LOW-MASK') > 0) THEN
          IFLD = 2
          IF (NFLD < 2) GOTO 905
          READ(CFLD(IFLD), *, ERR = 910) LOW_MASK
        ! READING MAXIMUM MAP DIMENSION
        ELSEIF (INDEX(CFLD(1), 'MAXIMUM') > 0) THEN
          IFLD = 4
          IF (NFLD < IFLD) GOTO 905
          READ(CFLD(IFLD), "(I4)", ERR = 910) MAXDIM
        ! READING OUTPUT UNIT TO CONVERT TO
        ELSEIF (INDEX(CFLD(1), 'OUTPUT-UNITS') > 0) THEN
          IF (NFLD < 4) GOTO 905
          !
          ! READ AND CHECK PRESSURE UNITS
          IFLD = 2
          TMP_UNIT = 'SI'
          READ(CFLD(IFLD), "(A)", ERR = 910) UNIT_OUT(1)
          CALL CALC_CONV_FACT('PRES', UNIT_OUT(1), TMP_UNIT, TMP, BOK)
          IF (.NOT. BOK) GOTO 910
          !
          ! READ AND CHECK DISTANCE UNITS
          IFLD = 3
          TMP_UNIT = 'SI'
          READ(CFLD(IFLD), "(A)", ERR = 910) UNIT_OUT(2)
          CALL CALC_CONV_FACT('DIST', UNIT_OUT(2), TMP_UNIT, TMP, BOK)
          IF (.NOT. BOK) GOTO 910
          !
          ! READ AND CHECK FLOW RATE UNITS
          IFLD = 4
          TMP_UNIT = 'SI'
          READ(CFLD(IFLD), "(A)", ERR = 910) UNIT_OUT(5)
          CALL CALC_CONV_FACT('FLOW', UNIT_OUT(5), TMP_UNIT, TMP, BOK)
          IF (.NOT. BOK) GOTO 910
          !
          OUTPUT_UNIT = .TRUE.
        ELSE
          CVAR = TRIM(CVAR(1:120)) !SHORTENING LENGTH TO PREVENT OVERFLOW
          CVAR = " ** WARNING: UNRECOGNIZED INPUT: "//TRIM(CVAR)//" **"
          CALL MESSAGE(CVAR)
        END IF
        CALL LNPROC(IUNIT,MAXFLD,MAXLEN,CVAR,CFLD,LFLD,NFLD,'SAME')
      END DO
C
C     SETTING OUTPUT UNITS IF NONE PROVIDED
      IF (.NOT. OUTPUT_UNIT) UNIT_OUT = UNIT_IN
C
C     CLOSING INPUT FILES
      CLOSE(IUNIT)
C
      RETURN
C
  905 CALL INSUFFICIENT_ERROR("INITIALIZATION")
      CALL MESSAGE(CVAR)
      GOTO 1000
C
  910 CALL FIELD_ERROR("INITIALIZATION", IFLD)
      CALL MESSAGE(CVAR)
      GOTO 1000
C
 1000 BOK = .FALSE.
      RETURN
C
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE READ_AP_MAP(IUNIT, BOK)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     PROGRAM DESCRIPTION: READS AND PROCESSING THE APERTURE MAP DATA
C
C     LAST MODIFIED: 2017/03/03
C
C     SUBROUTINE CALLS: LNPROC, CALC_PERCENTILE, MAP_STATS
C
C ---------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       RAW_APER - THE AVERAGE APERATURE OF THE MAP BEFORE AND ROUGHNESS OR MASKING IS PERFORMED
C       ZEROS - NUMBER OF TRUE ZEROS IN THE APERTURE MAP
C       MASK - NUMBER OF CELLS THAT WERE ADJUSTED BY THE HIGH AND LOW MASKS
C       BOK - CONTROL VARIABLE USED TO HALT PROGRAM IF A FATAL ERROR IS ENCOUNTERED
C
C ---------------------------------------------------------------------
C
      USE APM_MODULE
      USE IO_MODULE, ONLY : BLANK, MESSAGE
      USE MAP_MODULE
      USE OUTPUT_MODULE, ONLY : CALC_PERCENTILE
      USE STRING_MODULE, ONLY : MAXLEN
      USE UNIT_CONVERSION_MODULE, ONLY : VOX_MET
C
      IMPLICIT NONE
      INTEGER, INTENT(IN) :: IUNIT
      LOGICAL, INTENT(IN OUT) :: BOK
      !
      REAL(8), ALLOCATABLE :: AP_MAP(:,:), STAT_VALS(:)
      REAL(8) :: RAW_APER, MIN_APER, MAX_APER
      INTEGER :: I,IX,IZ !ITERATORS
      INTEGER :: ZEROS,MASK !SIZE/COUNTERS
      CHARACTER(MAXLEN), ALLOCATABLE :: STAT_KEYS(:)
      CHARACTER(MAXLEN) :: CVAR
C
C     FIRST LINE OF AP MAP DATA IS THE BOTTOM OF THE CORE
C     NUM OF RADIAL CELLS = NX, NUM OF LENGTH CELLS = NZ
      CALL BLANK
      CALL MESSAGE(" READING APERTURE MAP")
      CALL READ_DATA_MAP(AP_MAP, IUNIT, MAXDIM, BOK)
      IF (.NOT. BOK) GOTO 1000
      CLOSE(IUNIT)
      NX = SIZE(AP_MAP, DIM=2)
      NZ = SIZE(AP_MAP, DIM=1)
      !
      CALL ALLOCATE_FRAC(NX, NZ)
C
C     CONVERTING CT GRID SIZE TO SI DISTANCES
      ! MAP AVERAGING ONLY AFFECTS X AND Z DIRECTIONS
      DIAM = NX * VOX_MET * AVG_FACT
      LENG = NZ * VOX_MET * AVG_FACT
C
C     CALCULATING PERCENTILE RANGES OF APERTURES
      IF (PERCENTILE) THEN
        CALL MESSAGE('     CALCULATING APERTURE PERCENTILES OF MAP')
        CALL CALC_PERCENTILE(AP_MAP, PERC_ARR)
      END IF !ENDS PERCENTILE CONDITIONAL
C
C     COLLECTING MAP STATS AND MASKING CELLS
      RAW_APER = SUM(AP_MAP) / (NX * NZ)
      ZEROS = COUNT(INT(AP_MAP * 1E9) == 0)
      MAX_APER = MAXVAL(AP_MAP)
      MIN_APER = MINVAL(AP_MAP, MASK=AP_MAP > 0)
      MASK = COUNT(AP_MAP > HIGH_MASK) + COUNT(AP_MAP < LOW_MASK)
      !
      WHERE (AP_MAP > HIGH_MASK) AP_MAP = HIGH_MASK
      WHERE (AP_MAP < LOW_MASK) AP_MAP = LOW_MASK
      AVG_APER = SUM(AP_MAP) / (NZ * NX) * VOX_MET
C
C     CREATING POINT MAP
      CALL CREATE_POINT_MAP(AP_MAP, AP_POINT_MAP)
C
C     CREATING WIDTH VECTOR WITH ROUGHNESS ADJUSTMENT
      CVAR = "     CONVERTING 2-D MAP ARRAY IN VOX TO VECTOR IN SI"
      CALL MESSAGE(CVAR)
      WRITE(CVAR,"(5X,'ROUGHNESS FACTOR APPLIED TO MAP ',F10.6)")R_FACT
      CALL MESSAGE(CVAR)
      !
      DO IZ = 1,NZ
        DO IX = 1,NX
          I = (IZ - 1) * NX + IX
          ! STORING WIDTH AS THE APERTURE VALUE MINUS ROUGHESS
          WIDTH(I) = AP_MAP(IZ,IX) - R_FACT
        END DO
      END DO
      WHERE (WIDTH < LOW_MASK) WIDTH = LOW_MASK
      !
      WIDTH = WIDTH * VOX_MET
      AP_MAP = AP_MAP * VOX_MET
C
C     GETTING ADDITIONAL STATS ON THE APERTURE MAP
      CALL MESSAGE("     CALCULATING ADDITIONAL MAP STATISTICS")
      CALL MAP_STATS(AP_MAP, STAT_KEYS, STAT_VALS)
      APER_RMS = STAT_VALS(1)
      APER_DEV = STAT_VALS(2)
      X_CORR = STAT_VALS(3) * AVG_FACT * VOX_MET
      Z_CORR = STAT_VALS(4) * AVG_FACT * VOX_MET
C
C     OUTPUTING NUMBER OF ZEROS AND WARNING MESSAGING
      IF (ZEROS > 0) THEN
        WRITE(CVAR,2150) ZEROS
        CALL BLANK
        CALL MESSAGE(CVAR)
        WRITE(CVAR,2155)
        IF (LOW_MASK < 0.0001) CALL MESSAGE(CVAR)
      END IF
C
C     OUTPUTTING DATA ABOUT MAP
      CALL BLANK
      CALL MESSAGE("     PROPERTIES OF APERTURE MAP:")
      CALL BLANK
      WRITE(CVAR,2015) VOX_MET
      CALL MESSAGE(CVAR)
      WRITE(CVAR,2020) AVG_FACT
      CALL MESSAGE(CVAR)
      CALL BLANK
      WRITE(CVAR,2000)'DIAMETER[M]','LENGTH[M]'
      CALL MESSAGE(CVAR)
      WRITE(CVAR,2005) DIAM,LENG,NX,NZ
      CALL MESSAGE(CVAR)
C
      CALL BLANK
      WRITE(CVAR,2100)MASK
      CALL MESSAGE(CVAR)
      CALL BLANK
      WRITE(CVAR,2175)'MINIMUM, NONZERO',MIN_APER
      CALL MESSAGE(CVAR)
      WRITE(CVAR,2175)'MAXIMUM',MAX_APER
      CALL MESSAGE(CVAR)
      CALL BLANK
      WRITE(CVAR,2125)'WITHOUT MASK APPLIED: ',RAW_APER
      CALL MESSAGE(CVAR)
      WRITE(CVAR,2125)'WITH MASK APPLIED:    ',AVG_APER/VOX_MET
      CALL MESSAGE(CVAR)
C
C     OUTPUTTING PERCENTILES IF REQUESTED
      IF (PERCENTILE) THEN
        CALL BLANK
        WRITE(CVAR,2200)
        CALL MESSAGE(CVAR)
        WRITE(CVAR,2225)'PERCENTILE','[VOX]','[MM]'
        CALL MESSAGE(CVAR)
        DO I = 1,NPCT
          WRITE(CVAR,2230)PERC_ARR(1,I),PERC_ARR(2,I),
     &                    PERC_ARR(2,I)*VOX_MET*1000
          CALL MESSAGE(CVAR)
        END DO
      END IF
C
C     PERFORM DEALLOCATIONS
      DEALLOCATE(AP_MAP, STAT_VALS, STAT_KEYS)
C
 1000 RETURN
C
C     LINE FORMATTING
C
 2000 FORMAT(3X,A17,1X,A19,9X,'NX',8X,'NZ')
 2005 FORMAT(5X,F15.6,5X,F15.6,5X,I6.5,4X,I6.5)
C
 2015 FORMAT(9X,'VOXEL TO METER CONVERSION USED: ',E17.6)
 2020 FORMAT(9X,'MAP AVERAGING FACTOR APPLIED: ',F15.6)
C
 2100 FORMAT(9X,'NUMBER OF CELLS THAT WERE MASKED: ',I0)
C
 2125 FORMAT(9X,'HOMOGENEOUS APERTURE OF FRACTURE ',A22,F15.6,' VOXELS')
C
 2150 FORMAT(5X,'*** WARNING: ',I0,' CELLS HAD AN APERTURE OF ZERO ***')
 2155 FORMAT(5X,'*** WARNING: A LOW MASK OF AT LEAST 0.0001 IS',
     &          ' RECOMMENDED ***')
C
 2175 FORMAT(9X,A,' APERTURE OF FRACTURE: ',F15.6,' VOXELS')
C
 2200 FORMAT(9X,'APERTURE RANGES BY PERCENTILE')
C
 2225 FORMAT(1X,A18,1X,A19,1X,A19)
C
 2230 FORMAT(12X,F7.3,5X,F15.6,5X,F15.9)
C
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE SOLVER
C
C     WRITTEN BY: MATTHEW STADELMAN
C     LAST MODIFIED: 2017/02/06
C
C     SUBROUTINE DESCRIPTION: CREATES THE COEFFICENT MATRIX AND SOLVES FOR THE
C         PRESSURE.
C
C     SUBROUTINE CALLS: ALLOCATE_COEF,DEFINE_BOUNDARY_CONDITINS,
C                       D4_REORDER, D4_SOLVER, DEALLOCATE_COEFF
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       X - STORES THE FINAL SOLUTIONS TO THE LINEAR SYSTEM
C       NEUMANNG_X - STORES THE SOLUTION TO THE GROUP BC CELL
C
C ----------------------------------------------------------------------
C
      USE APM_MODULE
      USE D4_SOLVER_MODULE, ONLY : CC, TT, INIT_SOLVER, D4_SOLVER,
     &                             ADD_DIRICHLET_BOUND_COND,
     &                             ADD_NUEMANNG_BOUND_COND
      USE IO_MODULE, ONLY : BLANK, MESSAGE
C
      IMPLICIT NONE
      REAL(8) :: NEUMANNG_X, ST, EN
      REAL(8), ALLOCATABLE :: X(:)
      INTEGER :: I,IX,IZ
      CHARACTER(80) :: CVAR
C
C     INITIALIZING SOLVER
      CALL INIT_SOLVER(NX, NZ)
C
C     SWEEPING GRID TO POPULATE COEFFICIENT ARRAYS
      I = 0
      DO IZ = 1,NZ
        DO IX = 1,NX
          I = (IZ-1)*NX + IX
          TT(I,1) = -TRX(IZ,IX-1) !LEFT
          TT(I,2) = -TRX(IZ,IX)   !RIGHT
          TT(I,3) = -TRZ(IZ-1,IX) !DOWN
          TT(I,4) = -TRZ(IZ,IX)   !TOP
          CC(I) = -SUM(TT(I,:))
        END DO
      END DO
C
C     SETTING PRESSURE BCs
      IF (OUTPB .GE. 0) THEN
        CALL ADD_DIRICHLET_BOUND_COND(OUTLET_SIDE, OUTPB)
      END IF
      !
      IF (INLPB .GE. 0) THEN
        CALL ADD_DIRICHLET_BOUND_COND(INLET_SIDE, INLPB)
      END IF
C
C     DEFINING GROUP FLOW BCs
      IF (INJRATE .GT. 0.0) THEN !INLET FLOW RATE BC
        CALL ADD_NUEMANNG_BOUND_COND(INLET_SIDE, INJRATE)
      END IF
      !
      IF (OUTRATE .GT. 0.0) THEN !OUTLET FLOW RATE BC
        CALL ADD_NUEMANNG_BOUND_COND(OUTLET_SIDE, -OUTRATE)
      END IF
C
C
C     CALLING THE SOLVER ALGORITHM
      CALL BLANK
      CALL MESSAGE('     USING D4 GAUSS SOLVER')
      CALL CPU_TIME(ST)
      CALL D4_SOLVER(X, NEUMANNG_X)
      CALL CPU_TIME(EN)
      WRITE(CVAR,"(5X,'REQUIRED TIME FOR SOLUTION: ',F13.6)")(EN-ST)
      CALL MESSAGE(CVAR)
C
C     UPDATING THE FRACTURE PRESSURE
      DO IZ = 1,NZ
        DO IX = 1,NX
          I = (IZ - 1)*NX + IX
          FRAC_PR(IZ,IX) = X(I)
        END DO
      END DO
C
C     SETTING FLOW RATE DETERMINED INLET OR OUTLET PRESSURE
      IF (.NOT. PRESC) THEN
        IF (INJRATE .GT. 0.0) THEN !INLET FLOW RATE BC
          INLPB = NEUMANNG_X
        END IF
        !
        IF (OUTRATE .GT. 0.0) THEN !OUTLET FLOW RATE BC
          OUTPB = NEUMANNG_X
        END IF
      END IF
C
C
      DEALLOCATE(X)
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C

      SUBROUTINE FRAC_FLOW
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     DATE WRITTEN:  2015/03/02
C     LAST MODIFIED: 2017/02/06
C
C     PROGRAM DESCRIPTION: SOLVES FOR THE STEADY STATE FLOW THROUGH A
C         FRACTURE.
C
C     SUBROUTINE CALLS: SOLVER
C
C ---------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       Q(1:4,:) - STORES THE STEADY STATE FLOW THROUGH A CELL IN ORDER OF LEFT,RIGHT,BOTTON,TOP
C       Q(5,:) - STORES THE FINAL NET MASS GAIN/LOSS FOR A CELL
C       BOK - CONTROL VARIABLE USED TO HALT PROGRAM IF A FATAL ERROR IS ENCOUNTERED
C
C ---------------------------------------------------------------------
C
      USE APM_MODULE
C
      IMPLICIT NONE
      INTEGER :: I,IX,IZ
C
C     SOLVING FOR STEADY STATE FLOW PRESSURE DISTRIBUTION
      CALL SOLVER
C
C     HANDLING EACH OUTFLOW SIDE CASE TO SET BOUNDARY PRESSURES
      IF (INDEX(OUTLET_SIDE,'LEFT') > 0) THEN
        FRAC_PR(:,0) = OUTPB !EXTRA LEFT COUMN
        FRAC_PR(:,NX+1) = INLPB !EXTRA RIGHT COLUMN
        FRAC_PR(0,:) = INLPB !EXTRA BOTTOM ROW
        FRAC_PR(NZ+1,:) = INLPB !EXTRA TOP ROW
      ELSE IF (INDEX(OUTLET_SIDE,'RIGHT') > 0) THEN
        FRAC_PR(:,0) = INLPB !EXTRA LEFT COUMN
        FRAC_PR(:,NX+1) = OUTPB !EXTRA RIGHT COLUMN
        FRAC_PR(0,:) = INLPB !EXTRA BOTTOM ROW
        FRAC_PR(NZ+1,:) = INLPB !EXTRA TOP ROW
      ELSE IF (INDEX(OUTLET_SIDE,'TOP') > 0) THEN
        FRAC_PR(:,0) = INLPB !EXTRA LEFT COUMN
        FRAC_PR(:,NX+1) = INLPB !EXTRA RIGHT COLUMN
        FRAC_PR(0,:) = INLPB !EXTRA BOTTOM ROW
        FRAC_PR(NZ+1,:) = OUTPB !EXTRA TOP ROW
      ELSE IF (INDEX(OUTLET_SIDE,'BOTTOM') > 0) THEN
        FRAC_PR(:,0) = INLPB !EXTRA LEFT COUMN
        FRAC_PR(:,NX+1) = INLPB !EXTRA RIGHT COLUMN
        FRAC_PR(0,:) = OUTPB !EXTRA BOTTOM ROW
        FRAC_PR(NZ+1,:) = INLPB !EXTRA TOP ROW
      END IF
C
C     CALCULATING THE FINAL FLOW RATES FOR CELLS IN THE FRACTURE
      Q(:,:) = 0.0
      DO IZ = 1,NZ
        DO IX = 1,NX
          I = (IZ-1)*NX+IX
          Q(1,I) = -TRX(IZ,IX-1)*(FRAC_PR(IZ,IX)-FRAC_PR(IZ,IX-1))!LEFT
          Q(2,I) = -TRX(IZ,IX)*(FRAC_PR(IZ,IX+1) - FRAC_PR(IZ,IX))!RIGHT
          Q(3,I) = -TRZ(IZ-1,IX)*(FRAC_PR(IZ,IX)-FRAC_PR(IZ-1,IX))!BOTTOM
          Q(4,I) = -TRZ(IZ,IX)*(FRAC_PR(IZ+1,IX) - FRAC_PR(IZ,IX))!TOP
          Q(5,I) = ((Q(1,I)-Q(2,I))+(Q(3,I)-Q(4,I))) !NET RES
        END DO
      END DO
C
      RETURN
C
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE OUTPUT_DATA(BOK)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     PROGRAM DESCRIPTON: OUTPUTS THE DATA FROM THE LCL MODEL INTO
C         INTO SEVERAL FILES FOR POST-PROCESSING AND VIEWING.
C
C     DATE WRITTEN:  2015/03/02
C     LAST MODIFIED: 2017/03/03
C
C     SUBROUTINE CALLS: INIT_OUTPUT, CALC_PERCENTILE, WRITE_PERCENTILE
C         WRITE_STATS_FILE, WRITE_DATA_MAP
C
C ---------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       QX_OUT - X FLOW DATA USED FOR VECTOR PLOTTING
C       QZ_OUT - Z FLOW DATA USED FOR VECTOR PLOTTING
C       QZ_OUT - FLOW MAGNITUDE DATA USED FOR FLOW MAP AND REYNOLDS CALCULATION
C       PRES - FLATTENED VERSION OF FRAC_PR, WITHOUT BOUNDARY CELLS
C       REN - ARRAY THAT STORES THE ESTIMATED REYNOLDS NUMBER FOR A CELL
C       RES - ARRAY THAT STORES NORMALIZED MASS/GAIN LOSSES FOR A CELL
C       X,Y,Z - POINT COORDINATES USED TO CREATE VTK MESH
C
C ----------------------------------------------------------------------
C
      USE APM_MODULE
      USE IO_MODULE, ONLY : BLANK, MESSAGE, IMAP, IPRES, IVTK,
     &                      IFLOX, IFLOZ, IFLOM
      USE OUTPUT_MODULE, ONLY : CALC_PERCENTILE, WRITE_PERCENTILE,
     &                          WRITE_ONED_ARRAY
      USE STRING_MODULE, ONLY : MAXLEN
      USE UNIT_CONVERSION_MODULE, ONLY : VOX_MET
C
      IMPLICIT NONE
      LOGICAL, INTENT(IN OUT) :: BOK
      !
      REAL(8), ALLOCATABLE :: QX_OUT(:),QZ_OUT(:),QM_OUT(:),PRES(:)
      REAL(8), ALLOCATABLE :: REN(:),RES(:)
      REAL(8) :: FLOW
      INTEGER :: I,IC,IX,IZ,LB
      CHARACTER(MAXLEN) :: CVAR
C
C     INITIALIZING VARIABLES
      LB = NX*NZ
      ALLOCATE(QX_OUT(LB), QZ_OUT(LB), QM_OUT(LB), PRES(LB))
      ALLOCATE(RES(LB), REN(LB))
C
C     INITIALIZING OUTPUT FILES
      CALL INIT_OUTPUT(BOK)
      IF (.NOT. BOK) GOTO 1000
C
C     NORMALIZING RESIDUAL ARRAY BY THE LARGEST RESIDUAL VALUE
      RES = ABS(Q(5, :))
      RES = RES / MAXVAL(RES)
C
C     SETTING FLOW OUT ARRAYS BASED ON OUTLET SIDE
      QX_OUT = Q(2, :) !DEFAULT RIGHT
      QZ_OUT = Q(4, :) !DEFAULT TOP
      IF (INDEX(OUTLET_SIDE, 'LEFT') > 0) THEN
        QX_OUT = Q(1, :)
      ELSEIF (INDEX(OUTLET_SIDE, 'BOTTOM') > 0) THEN
        QZ_OUT = Q(3, :)
      END IF
C
C     CALCULATING FLOW MAGNITUDE AND APPROXIMATE REYNOLDS NUMBER
      QM_OUT = SQRT(QX_OUT**2 + QZ_OUT**2)
      REN = (RHO / AVG_VISC) * (QM_OUT / WIDTH)
C
C     CREATING FLATTENED PRESSURE ARRAY
      DO IZ =1,NZ
        DO IX = 1,NX
          I = (IZ - 1)*NX + IX
          PRES(I) = FRAC_PR(IZ, IX)
        END DO
      END DO
C
C     CALCULATING FLOW RATE FROM FRACTURE
      FLOW = 0.0
      DO IC = 1, NC
        I = OUTLET(IC)
        IF (INDEX(OUTLET_SIDE, 'LEFT') > 0)   FLOW = FLOW + Q(1, I)
        IF (INDEX(OUTLET_SIDE, 'RIGHT') > 0)  FLOW = FLOW + Q(2, I)
        IF (INDEX(OUTLET_SIDE, 'TOP') > 0)    FLOW = FLOW + Q(3, I)
        IF (INDEX(OUTLET_SIDE, 'BOTTOM') > 0) FLOW = FLOW + Q(4, I)
      END DO
      OUTRATE = ABS(FLOW)
C
C     CONVERTING VALUES IN INTERNAL UNITS TO OUTPUT UNITS
      AP_POINT_MAP = AP_POINT_MAP * VOX_MET * DIM_CONV
      PRES = PRES * PRES_CONV
      DX = DX * DIM_CONV
      DZ = DZ * DIM_CONV
      WIDTH = WIDTH * DIM_CONV
      OUTRATE = OUTRATE * RATE_CONV
      QX_OUT = QX_OUT * RATE_CONV
      QZ_OUT = QZ_OUT * RATE_CONV
      QM_OUT = QM_OUT * RATE_CONV
C
C     LOGGING FINAL PRESSURES, FLOW RATES AND RESIDUAL TO SCREEN
      CALL BLANK
      WRITE(CVAR,2000) 'INLET', INLPB * PRES_CONV, TRIM(UNIT_OUT(1))
      CALL MESSAGE(CVAR)
      WRITE(CVAR,2000) 'OUTLET', OUTPB * PRES_CONV, TRIM(UNIT_OUT(1))
      CALL MESSAGE(CVAR)
      WRITE(CVAR,2100) 'NET', OUTRATE, TRIM(UNIT_OUT(5))
      CALL MESSAGE(CVAR)
      WRITE(CVAR,2200) Q(5, MAXLOC(ABS(Q(5, :))))
      CALL MESSAGE(CVAR)
C
C     CALCULATING FLOW RATE PERCENTILES FOR X, Z COMPONENTS AND MAGNITUDE
      IF (PERCENTILE) THEN
        CALL CALC_PERCENTILE(QX_OUT, PERC_ARR)
        CALL WRITE_PERCENTILE(PERC_ARR, 'X-FLOW', UNIT_OUT(5))
        !
        CALL CALC_PERCENTILE(QZ_OUT, PERC_ARR)
        CALL WRITE_PERCENTILE(PERC_ARR, 'Z-FLOW', UNIT_OUT(5))
        !
        CALL CALC_PERCENTILE(QM_OUT, PERC_ARR)
        CALL WRITE_PERCENTILE(PERC_ARR, 'FLOW MAGNITUDE', UNIT_OUT(5))
C
C       CALCULATING PERCENTILES FOR THE NORMALIZED RESIDUAL
        CALL CALC_PERCENTILE(RES, PERC_ARR)
        CALL WRITE_PERCENTILE(PERC_ARR, 'NORMALIZED RESIDUAL', '-')
      END IF
C
      CALL BLANK
      CALL MESSAGE(" WRITING DATA TO OUTPUT FILES...")
C
C     OUTPUTTING DATA TO STATS FILE
      CALL WRITE_STATS_FILE(FLOW)
C
C     OUTPUTTING THE WIDTH VECTOR USED IN THE SIMULATION
      CALL WRITE_ONED_ARRAY(IMAP, WIDTH, NX, NZ, "(*(G15.8,:,','))")
      CALL MESSAGE("     ADJUSTED APERTURE FILE COMPLETED")
C
C     OUTPUTTING QX, QZ AND FLOW MAGNITUDE VALUES
      CALL WRITE_ONED_ARRAY(IFLOX, QX_OUT, NX, NZ, "(*(G15.8,:,','))")
      CALL WRITE_ONED_ARRAY(IFLOZ, QZ_OUT, NX, NZ, "(*(G15.8,:,','))")
      CALL WRITE_ONED_ARRAY(IFLOM, QM_OUT, NX, NZ, "(*(G15.8,:,','))")
      CALL MESSAGE("     FLOW FILE COMPLETED")
C
C     OUTPUTTING THE FRACTURE PRESSURE DISTRIBUTION
      CALL WRITE_ONED_ARRAY(IPRES, PRES, NX, NZ, "(*(G15.8,:,','))")
      CALL MESSAGE("     PRESSURE FILE COMPLETED")
C
C     WRITTING VTK FILE
      CALL WRITE_VTK_FILE(IVTK, QX_OUT, QZ_OUT, PRES, REN, RES)
C
C     DEALLOCATING ARRAYS
      DEALLOCATE(QX_OUT, QZ_OUT, QM_OUT, PRES, REN, RES)
      CALL DEALLOCATE_FRAC
C
      CALL BLANK
      CALL MESSAGE(" DEALLOCATED ALL ARRAYS")
C
      RETURN
C
 1000 BOK = .FALSE.
      RETURN
C
 2000 FORMAT(5X, A, ' BOUNDARY PRESSURE: ', G20.9, 1X, A)
C
 2100 FORMAT(5X, A, ' FLOW RATE CALCULATED: ', G20.9, 1X, A)
C
 2200 FORMAT(5X, 'MAXIMUM NET FLOW RESIDUAL: ', G20.9, 1X, A)
C
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE INIT_OUTPUT(BOK)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     LAST MODIFIED: 2016/07/12
C
C     PROGRAM DESCRIPTION: PREPARES OUTPUT FILES
C
C     SUBROUTINE CALLS: CALC_CONV_FACT, SET_HEADER
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       CONV - STORES THE VALUE OF EACH UNIT CONVERSION TO PRINT TO SCREEN
C       BOK - CONTROL VARIABLE USED TO HALT PROGRAM IF A FATAL ERROR IS ENCOUNTERED
C
C ----------------------------------------------------------------------
C
      USE APM_MODULE
      USE IO_MODULE, ONLY : BLANK, MESSAGE
      USE STRING_MODULE, ONLY : MAXLEN
      USE UNIT_CONVERSION_MODULE, ONLY : CALC_CONV_FACT
C
      IMPLICIT NONE
      LOGICAL, INTENT(IN OUT) :: BOK
      !
      REAL(8) :: CONV(7)
      INTEGER :: I
      CHARACTER(MAXLEN) :: CVAR
C
      CONV(1) = PRES_CONV
      CONV(2) = DIM_CONV
      CONV(4) = TIME_CONV
      CONV(5) = RATE_CONV
      CONV(6) = VISC_CONV
      CONV(7) = RHO_CONV
      UNIT_OUT(6) = UNIT_IN(6)
      UNIT_OUT(7) = UNIT_IN(7)
C
      CALL BLANK
      CALL MESSAGE(" INITIALIZING OUTPUT FILES")
      CALL MESSAGE("     INPUT CONVERSIONS APPLIED")
      CALL CALC_CONV_FACT('PRES', UNIT(1), UNIT_OUT(1), PRES_CONV, BOK)
      CALL CALC_CONV_FACT('DIST', UNIT(2), UNIT_OUT(2), DIM_CONV, BOK)
      CALL CALC_CONV_FACT('TIME', UNIT(4), UNIT_OUT(4), TIME_CONV, BOK)
      CALL CALC_CONV_FACT('RATE', UNIT(5), UNIT_OUT(5), RATE_CONV, BOK)
      CALL CALC_CONV_FACT('VISC', UNIT(6), UNIT_OUT(6), VISC_CONV, BOK)
      CALL CALC_CONV_FACT('DENS', UNIT(7), UNIT_OUT(7), RHO_CONV, BOK)
      IF (.NOT. BOK) GOTO 1000
C
      WRITE(CVAR, 1990)
      CALL MESSAGE(CVAR)
      WRITE(CVAR, 1980) 'UNIT IN', 'UNIT OUT', 'CONVERSION'
      CALL MESSAGE(CVAR)
      WRITE(CVAR, 1990)
      CALL MESSAGE(CVAR)
      DO I = 1,7
        IF (I == 3) CYCLE
        WRITE(CVAR, 2000) UNIT_IN(I), UNIT(I), CONV(I)
      CALL MESSAGE(CVAR)
      END DO
      WRITE(CVAR, 1990)
      CALL MESSAGE(CVAR)
C
      CONV(1) = PRES_CONV
      CONV(2) = DIM_CONV
      CONV(4) = TIME_CONV
      CONV(5) = RATE_CONV
      CONV(6) = VISC_CONV
      CONV(7) = RHO_CONV
C
      CALL BLANK
      CALL MESSAGE("     OUTPUT CONVERSIONS APPLIED")
      WRITE(CVAR, 1990)
      CALL MESSAGE(CVAR)
      WRITE(CVAR, 1980) 'UNIT IN','UNIT OUT','CONVERSION'
      CALL MESSAGE(CVAR)
      WRITE(CVAR, 1990)
      CALL MESSAGE(CVAR)
      DO I = 1, 7
        IF (I == 3) CYCLE
        WRITE(CVAR, 2000) UNIT(I), UNIT_OUT(I), CONV(I)
      CALL MESSAGE(CVAR)
      END DO
      WRITE(CVAR, 1990)
      CALL MESSAGE(CVAR)
C
      RETURN
C
 1000 BOK = .FALSE.
      RETURN
C
 1980 FORMAT(5X,A10,4X,A10,2X,A15)
 1990 FORMAT(5X,41('-'))
 2000 FORMAT(5X,A10,' -> ',A10,': ',G15.6)
C
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE WRITE_STATS_FILE(FLOW)
C
C     WRITTEN BY: MATTHEW STADELMAN
C
C     LAST MODIFIED: 2016/10/27
C
C     PROGRAM DESCRIPTION: SETS THE HEADER USED IN CERTAIN OUTPUT FILES
C
C     SUBROUTINE CALLS: NONE
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       FLOW - TOTAL FLOW OUT OF THE FRACTURE
C       FLOW_CF - REPRESENTS THE DISCREPANCY BETWEEN CUBIC LAW AND LOCAL
C           CUBIC LAW (Q LCL)/(Q CL)
C       NFQ - 1-D EQUIVALENT FLOW
C       AVG_CORR - AVERAGE OF X AND Z CORRELTION LENGTHS, USED IN CALCULATIONS
C       BULK_REN - OVERALL REYNOLDS NUMBER FOR THE FRACTURE
C       HOM_TRANS - AVERAGE FRACTURE TRANSMISSIVITY BASED ON FLOW AND DP
C       AVG_TRX, AVG_TRZ - AVERAGE TRANSMISSIVITY BASED ON MEAN APERTURE
C       HYD_APER - HYDRAULIC APERTURE BACK CALCULATED FROM FLOW
C ----------------------------------------------------------------------
C
      USE APM_MODULE
      USE IO_MODULE, ONLY : APM_FILE, ISTATC, ISTATY
C
      IMPLICIT NONE
      REAL(8), INTENT(IN) :: FLOW
      !
      REAL(8) :: FLOW_CF, NFQ, BULK_REN, DP
      REAL(8) :: AVG_CORR, AVG_TRX, AVG_TRZ, HOM_TRANS, HYD_APER
      INTEGER :: VERT, HORIZ
C
C     DEFINING AN AVERAGE HOMONGENOUS TRANSMISSIVITY
      AVG_TRX = (LENG*AVG_APER**3)/(12.0*DIAM)/AVG_VISC
      AVG_TRZ = (DIAM*AVG_APER**3)/(12.0*LENG)/AVG_VISC
C
C     CALCULATING FLOW CORRECTION FACTOR AND THE 1-D EQUIVALENT FLOW RATE
      VERT = INDEX(OUTLET_SIDE, 'TOP') + INDEX(OUTLET_SIDE, 'BOTTOM')
      HORIZ = INDEX(OUTLET_SIDE, 'RIGHT') + INDEX(OUTLET_SIDE, 'LEFT')
      IF (HORIZ > 0) THEN
        FLOW_CF =   ABS(FLOW/(INLPB - OUTPB)/AVG_TRX)
        NFQ =       ABS(AVG_TRX * (INLPB - OUTPB))
        HOM_TRANS = ABS(FLOW/(INLPB - OUTPB)) * AVG_VISC * DIAM
        HYD_APER =  ABS(FLOW/(INLPB - OUTPB)) * 12.0*AVG_VISC*DIAM/LENG
        BULK_REN =  ABS(2.0*RHO*FLOW)/(AVG_VISC*LENG)
      ELSEIF (VERT > 0) THEN
        FLOW_CF =   ABS(FLOW/(INLPB-OUTPB)/AVG_TRZ)
        NFQ =       ABS(AVG_TRZ * (INLPB - OUTPB))
        HOM_TRANS = ABS(FLOW/(INLPB-OUTPB))*AVG_VISC*LENG
        HYD_APER =  ABS(FLOW/(INLPB - OUTPB)) * 12.0*AVG_VISC*LENG/DIAM
        BULK_REN =  ABS(2.0*RHO*FLOW)/(AVG_VISC*DIAM)
      END IF
      HYD_APER = HYD_APER**(1.0/3.0)
C
C     HANDLING UNIT CONVERSIONS
      DIAM = DIAM*DIM_CONV
      LENG = LENG*DIM_CONV
      AVG_APER = AVG_APER*DIM_CONV
      HYD_APER = HYD_APER*DIM_CONV
      AVG_VISC = AVG_VISC*VISC_CONV
      RHO = RHO*RHO_CONV
      APER_RMS = APER_RMS*DIM_CONV
      APER_DEV = APER_DEV*DIM_CONV
      Z_CORR = Z_CORR*DIM_CONV
      X_CORR = X_CORR*DIM_CONV
      INLPB = INLPB * PRES_CONV
      OUTPB = OUTPB * PRES_CONV
      NFQ = NFQ*RATE_CONV
      AVG_CORR = (2.0*X_CORR*Z_CORR)/(X_CORR+Z_CORR)
      DP = (INLPB-OUTPB)/PRES_CONV
C
C    WRITING HEADER INFORMATION FOR CSV FILE
      WRITE(ISTATC,"(A)")'APER-MAP:, ' // TRIM(APM_FILE)
      WRITE(ISTATC,"('NX,NZ',/,I0,',',I0)") NX, NZ
      !
      WRITE(ISTATC,2050) TRIM(UNIT_OUT(2)), TRIM(UNIT_OUT(2)),
     &                   TRIM(UNIT_OUT(2))
      WRITE(ISTATC,2000) LENG, DIAM, AVG_APER
      !
      WRITE(ISTATC,2075) TRIM(UNIT_OUT(6)), TRIM(UNIT_OUT(7))
      WRITE(ISTATC,2000) AVG_VISC, RHO
C
C     OUTPUTTING DATA TO CSV STATISTICS FILE
      WRITE(ISTATC,2100) TRIM(UNIT_OUT(1)), TRIM(UNIT_OUT(1)),
     &                   TRIM(UNIT_OUT(5))
      WRITE(ISTATC,2000) INLPB, OUTPB, OUTRATE
      !
      WRITE(ISTATC,"(A)") '#'
      WRITE(ISTATC,2125) TRIM(UNIT_OUT(2)), TRIM(UNIT_OUT(2))
      WRITE(ISTATC,2000) APER_RMS, APER_DEV
      WRITE(ISTATC,"(A)") '#'
      WRITE(ISTATC,2140) TRIM(UNIT_OUT(2)), TRIM(UNIT_OUT(2)),
     &                   TRIM(UNIT_OUT(2))
      WRITE(ISTATC,2000) X_CORR, Z_CORR, AVG_CORR
      !
      WRITE(ISTATC,"(A)")'#'
      WRITE(ISTATC,2150)
      WRITE(ISTATC,2000) APER_DEV/AVG_APER, APER_DEV/AVG_CORR,
     &                   AVG_APER/AVG_CORR
      !
      WRITE(ISTATC,"(A)") '#'
      WRITE(ISTATC,2175)
      WRITE(ISTATC,2000) BULK_REN, HOM_TRANS, DP
      !
      WRITE(ISTATC,"(A)") '#'
      WRITE(ISTATC,2200) TRIM(UNIT_OUT(5))
      WRITE(ISTATC,2000) NFQ, FLOW_CF*100
C
C     WRITING DATA TO YAML FILE
      WRITE(ISTATY,"(A)") 'APER-MAP: ' // TRIM(APM_FILE)
      WRITE(ISTATY, "('NX: ',I0,/,'NZ: ',I0)") NX, NZ
      WRITE(ISTATY, 2500) 'LENGTH', LENG, TRIM(UNIT_OUT(2))
      WRITE(ISTATY, 2500) 'DIAMETER', DIAM, TRIM(UNIT_OUT(2))
      WRITE(ISTATY, 2500) 'MEAN APER', AVG_APER, TRIM(UNIT_OUT(2))
      WRITE(ISTATY, 2500) 'HYDRAULIC APER', HYD_APER, TRIM(UNIT_OUT(2))
      WRITE(ISTATY, 2500) 'AVG VISC', AVG_VISC, TRIM(UNIT_OUT(6))
      WRITE(ISTATY, 2500) 'DENSITY', RHO, TRIM(UNIT_OUT(7))
      WRITE(ISTATY, 2500) 'INLET PRESS', INLPB, TRIM(UNIT_OUT(1))
      WRITE(ISTATY, 2500) 'OUTLET PRESS', OUTPB, TRIM(UNIT_OUT(1))
      WRITE(ISTATY, 2500) 'OUTLET RATE', OUTRATE, TRIM(UNIT_OUT(5))
      WRITE(ISTATY, 2500) 'APERTURE RMS', APER_RMS, TRIM(UNIT_OUT(2))
      WRITE(ISTATY, 2500) 'APERTURE STDDEV', APER_DEV, TRIM(UNIT_OUT(2))
      WRITE(ISTATY, 2500) 'X-CORR LENGTH', X_CORR, TRIM(UNIT_OUT(2))
      WRITE(ISTATY, 2500) 'Z-CORR LENGTH', Z_CORR, TRIM(UNIT_OUT(2))
      WRITE(ISTATY, 2500) 'AVG-CORR LENGTH', AVG_CORR, TRIM(UNIT_OUT(2))
      WRITE(ISTATY, 2500) 'STDDEV/MEAN APER', APER_DEV/AVG_APER, '-'
      WRITE(ISTATY, 2500) 'STDDEV/AVG CORR LEN', APER_DEV/AVG_CORR, '-'
      WRITE(ISTATY, 2500) 'MEAN APER/AVG CORR LEN',AVG_APER/AVG_CORR,'-'
      WRITE(ISTATY, 2500) 'BULK REYNOLDS NUM', BULK_REN, '-'
      WRITE(ISTATY, 2500) 'AVERAGE TRANSMISSIBILTY', HOM_TRANS, 'M^4'
      WRITE(ISTATY, 2500) 'PRESSURE DIFFERENTIAL', DP, 'PA'
      WRITE(ISTATY, 2500) '1-D EQUIV', NFQ, TRIM(UNIT_OUT(5))
      WRITE(ISTATY, 2500) 'PERC OF 1-D', FLOW_CF*100, '-'
C
      RETURN
C
C     CSV FILE FORMATS
 2000 FORMAT(*(G20.12,:,','))
C
 2050 FORMAT('LENGTH [',A,'],DIAMETER [',A,'],MEAN APER [',A,'],')
C
 2075 FORMAT('AVG VISC [',A,'],DENSITY [',A,']')
C
 2100 FORMAT('INLET PRESS [',A,'],OUTLET PRESS [',A,'],',
     &       'OUTLET RATE [',A,']')
C
 2125 FORMAT('APERTURE RMS [',A,'],APERTURE STDDEV [',A,']')
C
 2140 FORMAT('X-CORR LENGTH [',A,'],Z-CORR LENGTH [',A,'],',
     &       'AVG-CORR LENGTH [',A,']')
C
 2150 FORMAT('STDDEV/MEAN APER [-],STDDEV/AVG CORR LEN [-],',
     &       ' MEAN APER/AVG CORR LEN [-]')
C
 2175 FORMAT('BULK REYNOLDS # [-],AVERAGE TRANSMISSIBILTY [M^4],',
     &       'PRESSURE DIFFERENTIAL [PA]')
C
 2200 FORMAT('1-D EQUIV [',A,'],PERC OF 1-D [-]')
C
C     YAML FILE FORMATS
 2500 FORMAT(A,': ','[',G20.12,',"',A,'"]')
C
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
      SUBROUTINE WRITE_VTK_FILE(IUNIT, QX, QZ, PRES, REN, RES)
C
C     WRITES MODEL DATA TO THE VTK FILE
C
      USE APM_MODULE
      USE IO_MODULE, ONLY : BLANK, MESSAGE
      IMPLICIT NONE
      REAL(8), INTENT(IN) :: QX(NX*NZ), QZ(NX*NZ), PRES(NX*NZ)
      REAL(8), INTENT(IN) :: REN(NX*NZ), RES(NX*NZ)
      INTEGER, INTENT(IN) :: IUNIT
      !
      REAL(8) :: X, Y, Z
      INTEGER :: IX, IZ, I, N
C
C     WRITE VTK FILE HEADER
      CALL BLANK
      CALL MESSAGE("     CREATING THE VTK FILE...")
      WRITE(IUNIT, "('# vtk DataFile Version 3.0')")
      WRITE(IUNIT, "('vtk output')")
      WRITE(IUNIT, "('ASCII')")
      WRITE(IUNIT, "('DATASET STRUCTURED_GRID')")
      WRITE(IUNIT, "('DIMENSIONS ',I0,1X,I0,1X,I0)") NX + 1, NZ + 1, 2
      WRITE(IUNIT, "('POINTS ',I0,' float')") (NX + 1) * (NZ + 1) * 2
C
C     OUTPUTTING BOTTOM AND TOP SURFACE GRID POINTS
      DO N = -1, 1, 2
        Z = 0.0
        DO IZ = 1, NZ
          X = 0.0
          Y = N * AP_POINT_MAP(IZ, 1, 1) / 2.0
          WRITE(IUNIT, "(3(E14.6,:,' '))") X, Y, Z
          DO IX = 1, NX
            I = (IZ - 1)*NX + IX
            X = X + DX(I)
            Y = N * AP_POINT_MAP(IZ, IX, 2) / 2.0
            WRITE(IUNIT, "(3(E14.6,:,' '))") X, Y, Z
          END DO
          Z = Z + DZ(I)
        END DO
        !
        X = 0.0
        Y = N * AP_POINT_MAP(NZ, 1, 4) / 2.0
        WRITE(IUNIT,"(3(E14.6,:,' '))")X, Y, Z
        DO IX = 1,NX
          I = (NZ - 1)*NX + IX
          X = X + DX(I)
          Y = N * AP_POINT_MAP(NZ, IX, 3) / 2.0
          WRITE(IUNIT,"(3(E14.6,:,' '))") X, Y, Z
        END DO
      END DO
      CALL MESSAGE("         VTK POINTS OUTPUT TO FILE")
C
C     OUTPUTTING SIMULATION DATA INTO THE VTK FILE
      CALL BLANK
      CALL MESSAGE("     OUTPUTTING DATA TO THE VTK FILE...")
C
C     CREATING THE CELL DATA TABLES
      WRITE(IUNIT, "(' ')")
      WRITE(IUNIT, "('CELL_DATA ', I0)") NX * NZ * 1
      CALL WRITE_VTK_DATA(IUNIT, 'APERTURE', UNIT_OUT(2), 'float',WIDTH)
      CALL WRITE_VTK_DATA(IUNIT, 'PRESSURE', UNIT_OUT(1), ' float',PRES)
      CALL WRITE_VTK_DATA(IUNIT, 'REYNOLDS_NUMBER', '-', 'float', REN)
      CALL WRITE_VTK_DATA(IUNIT, 'NORMALIZED_RESIDUAL', '-','float',RES)
C
      WRITE(IUNIT, "(' ')")
      WRITE(IUNIT, "('VECTORS FLOW[',A,'] float')") TRIM(UNIT_OUT(5))
      DO IZ = 1, NZ
        DO IX = 1, NX
          I = (IZ - 1) * NX + IX
          WRITE(IUNIT, "(3(E14.6,:,' '))") QX(I), 0.0, QZ(I)
        END DO
      END DO
      CALL MESSAGE("         VECTOR FLOW DATA OUTPUT TO VTK FILE")
C
      !
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C ######################################################################
C ----------------------------------------------------------------------
C
