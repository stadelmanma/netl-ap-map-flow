      MODULE D4_SOLVER_MODULE
C
C     WRITTEN BY: MATTHEW STADELMAN
C     FILE DESCRIPTION: STORES THE VARIABLES USED TO SOLVE THE
C         LINEAR SYSTEM OF EQUATIONS GENERATED BY THE LCL MODEL.
C
C     LAST MODIFIED: 2017/02/06
C ----------------------------------------------------------------------
C               ---- VARIABLE DESCRIPTIONS ----
C    COEFFICENT ARRAYS
C      CC - STORES THE VALUES ALONG THE MAIN DIAGONAL
C      TT - STORES THE OFF DIAGONAL TERMS FOR EACH ROW
C      RHS - STORES RHS VALUES FOR EACH ROW
C      NEUMANNG_COL, NUEMANNG_ROW - STORES CONNECTION VALUES TO THE GROUP NODE
C      NEUMANNG_CC - STORES THE MAIN DIAGONAL COMPONENT OF THE GROUP NODE ROW
C      NEUMANNG_RHS - STORES THE RIGHT HAND SIDE VALUE FOR GROUP NODE ROW
C
C    WORK ARRAYS
C      UPPER_D4 - STORES THE UPPER TRIANGLE OF THE LINEAR SYSTEM DURING ELIMINATION
C
C    INDEXING ARRAYS
C      LINK_D4 - STORES THE LEXOGRAPHICAL INDEX OF A VALUE IN D4 ORDER
C      INAT - COVERTS A D4 INDEX TO A LEXOGRAPHICAL INDEX
C      INO - CONVERTS A LEXOGRAPHICAL INDEX TO A D4 INDEX
C      IBASE_UPPER - USED TO ACCESS UPPER TRIANGLE VALUES FOR A SPECIFIC ROW
C
C    DATA EXTENTS
C      SOLV_NX - THE X-AXIS EXTENT OF THE SOLVER ARRAY AFTER BCs ARE ADDED
C      SOLV_NZ - THE Z-AXIS EXTENT OF THE SOLVER ARRAY AFTER BCs ARE ADDED
C      X_OFFSET - THE STARTING X-AXIS INDEX OF THE FIRST NON-BC CELL
C      Z_OFFSET - THE STARTING Z-AXIS INDEX OF THE FIRST NON-BC CELL
C      NUM_TOP - NUMBER OF ROWS IN THE TOP HALF OF LINEAR SYSTEM
C      NUM_BOTTOM - NUMBER OF ROWS IN THE LOWER HALF OF THE LINEAR SYSTEM
C      NUM_TOTAL - TOTAL NUMBER OF ROWS IN THE SYSTEM
C      MAX_BAND - THE MAXIMUM OFF DIAGONIAL INDEX IN THE LINEAR SYSTEM
C
C ----------------------------------------------------------------------
C
      PRIVATE
C
C     COEFFICENT ARRAYS
      REAL(8),ALLOCATABLE,SAVE :: CC(:), TT(:,:), RHS(:)
      REAL(8),ALLOCATABLE,SAVE :: NEUMANNG_ROW(:), NEUMANNG_COL(:)
      REAL(8),SAVE :: NEUMANNG_CC, NEUMANNG_RHS
C
C     WORK ARRAYS
      REAL(8),ALLOCATABLE,SAVE :: UPPER_D4(:)
C
C     INDEXING ARRAYS
      INTEGER,ALLOCATABLE,SAVE :: LINK_D4(:,:)
      INTEGER,ALLOCATABLE,SAVE :: INAT(:),INO(:)
      INTEGER,ALLOCATABLE,SAVE :: IBASE_UPPER(:)
C
C     DATA EXTENTS
      INTEGER,SAVE :: ORIG_NX, ORIG_NZ, SOLV_NX, SOLV_NZ
      INTEGER,SAVE :: X_OFFSET, Z_OFFSET
      INTEGER,SAVE :: NUM_TOP, NUM_BOTTOM, NUM_TOTAL, MAX_BAND
C
C     MODULE EXPORTS
      PUBLIC :: CC, TT
      PUBLIC :: INIT_SOLVER, D4_SOLVER
      PUBLIC :: ADD_DIRICHLET_BOUND_COND, ADD_NUEMANNG_BOUND_COND
C
      CONTAINS
C
C ----------------------------------------------------------------------
C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
C ----------------------------------------------------------------------
C
      SUBROUTINE ALLOCATE_COEF(NX ,NZ)
C
C     WRITTEN BY: MATTHEW STADELMAN
C     LAST MODIFIED: 2017/02/06
C
C     ALLOCATES THE SOLVER'S COEFFICIENT ARRAY
C
      IMPLICIT NONE
      INTEGER :: NX, NZ, NUM_BLK
      NUM_BLK = NX * NZ
      !
      ALLOCATE (NEUMANNG_ROW(NUM_BLK), NEUMANNG_COL(NUM_BLK))
      ALLOCATE (CC(NUM_BLK), TT(NUM_BLK,4), RHS(NUM_BLK))
      !
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
C ----------------------------------------------------------------------
C
      SUBROUTINE DEALLOCATE_COEF
C
C     WRITTEN BY: MATTHEW STADELMAN
C     LAST MODIFIED: 2017/02/06
C
C     DEALLOCATES THE SOLVER'S COEFFICIENT ARRAYS
C
      IMPLICIT NONE
      !
      DEALLOCATE(CC, TT, RHS, NEUMANNG_ROW, NEUMANNG_COL)
      !
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
C ----------------------------------------------------------------------
C
      SUBROUTINE INIT_SOLVER(NX, NZ)
C
C     WRITTEN BY: MATTHEW STADELMAN
C     LAST MODIFIED: 2017/02/06
C
C     INITIALIZES THE SOLVER MODULE ARRAYS AND COEFFICENTS
C
      IMPLICIT NONE
      INTEGER :: NX ,NZ
      !
      CALL ALLOCATE_COEF(NX, NZ)
      CALL RESET_COEF
      !
      ! INITIALIZING VARAIBLES
      ORIG_NX = NX
      ORIG_NZ = NZ
      SOLV_NX = NX
      SOLV_NZ = NZ
      !
      CC(:) = 1.0
      TT(:,:) = 0.0
      RHS(:) = 0.0
      !
      NEUMANNG_CC = 1.0
      NEUMANNG_RHS = 0.0
      NEUMANNG_COL(:) = 0.0
      NEUMANNG_ROW(:) = 0.0
      !
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
C ----------------------------------------------------------------------
C
      SUBROUTINE RESET_COEF
C
C     WRITTEN BY: MATTHEW STADELMAN
C     LAST MODIFIED: 2017/02/06
C
C     RESETS THE VALUES OF VARIOUS COEFFICENTS IN THE MODULE
C
      IMPLICIT NONE
      !
      X_OFFSET = 0
      Z_OFFSET = 0
      SOLV_NX = 0
      SOLV_NZ = 0
      ORIG_NX = 0
      ORIG_NZ = 0
      NEUMANNG_CC = 1.0
      NEUMANNG_RHS = 0.0
      !
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
C ----------------------------------------------------------------------
C
       SUBROUTINE ADD_DIRICHLET_BOUND_COND(SIDE, BC_VALUE)
C
C     WRITTEN BY: MATTHEW STADELMAN
C     DATE WRITTEN: 07/05/2016
C
C     SUBROUTINE DESCRIPTION: SETS A DIRICHLET BOUNDARY CONDITION ON A
C         SPECFIED SIDE. THE COEFFICENT ARRAYS ARE RESIZED IN THE PROCESS.
C         ALL DIRICHLET BOUNDARY CONDITIONS NEED TO BE APPLIED BEFORE ANY
C         NUEMANN BOUNDARY CONDITIONS
C
C     SUBROUTINE CALLS: ALLOCATE_COEF, DEALLOCATE_COEF, MESSAGE
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       SIDE - STRING REPRESENTING THE DESIRED SIDE TO ADD THE CONDTION
C       BC_VALUE - NUMERIC VALUE OF THE BOUNDARY CONDITION
C       BC_SLICE - STORES INCIDICES OF THE DIRICHLET CELLS ADDED
C       MV_SLICE - STORES THE INDICIES NEEDED TO MAP OLD VALUES TO NEW ARRAY DIMENSIONS
C
C ----------------------------------------------------------------------
C
      IMPLICIT NONE
      REAL(8), ALLOCATABLE :: NEW_CC(:),NEW_TT(:,:),NEW_RHS(:)
      REAL(8) :: BC_VALUE
      INTEGER, ALLOCATABLE :: BC_SLICE(:), MV_SLICE(:)
      INTEGER :: IB, IZ, OLD_NX, OLD_NZ, NXZ
      CHARACTER(*) :: SIDE
C
C     DETERMINING NEW DIMENSIONS OF SOLVER ARRAYS
      OLD_NX = SOLV_NX
      OLD_NZ = SOLV_NZ
      IF (INDEX(SIDE,'BOTTOM') > 0) THEN
        SOLV_NZ = SOLV_NZ + 1
        Z_OFFSET = Z_OFFSET + 1
        ALLOCATE(BC_SLICE(OLD_NX),MV_SLICE(OLD_NX*OLD_NZ))
        FORALL (IB = 1:OLD_NX) BC_SLICE(IB) = IB
        FORALL (IB = 1:OLD_NX*OLD_NZ) MV_SLICE(IB) = OLD_NX+IB
      ELSE IF (INDEX(SIDE,'TOP') > 0) THEN
        SOLV_NZ = SOLV_NZ + 1
        ALLOCATE(BC_SLICE(OLD_NX),MV_SLICE(OLD_NX*OLD_NZ))
        FORALL (IB = 1:OLD_NX) BC_SLICE(IB) = OLD_NX*OLD_NZ+IB
        FORALL (IB = 1:OLD_NX*OLD_NZ) MV_SLICE(IB) = IB
      ELSE IF (INDEX(SIDE,'LEFT') > 0) THEN
        SOLV_NX = SOLV_NX + 1
        X_OFFSET = X_OFFSET + 1
        ALLOCATE(BC_SLICE(OLD_NZ),MV_SLICE(OLD_NX*OLD_NZ))
        DO IZ = 0,OLD_NZ-1
          BC_SLICE(IZ+1) = IZ*SOLV_NX+1
          FORALL(IB = 1:OLD_NX) MV_SLICE(IZ*OLD_NX+IB)=IZ*SOLV_NX+IB+1
        END DO
      ELSE IF (INDEX(SIDE,'RIGHT') > 0) THEN
        SOLV_NX = SOLV_NX + 1
        ALLOCATE(BC_SLICE(OLD_NZ),MV_SLICE(OLD_NX*OLD_NZ))
        DO IZ = 0,OLD_NZ-1
          BC_SLICE(IZ+1) = IZ*SOLV_NX+SOLV_NX
          FORALL(IB = 1:OLD_NX) MV_SLICE(IZ*OLD_NX+IB)=IZ*SOLV_NX+IB
        END DO
      ELSE
        WRITE(*, 'INVALID BOUNDARY SIDE GIVEN: ' / /SIDE)
        RETURN
      END IF
C
C     ALLOCATING TEMP ARRAYS TO NEW SIZE
      NXZ = SOLV_NZ * SOLV_NX
      ALLOCATE(NEW_CC(NXZ), NEW_TT(NXZ, 4), NEW_RHS(NXZ))
      NEW_CC(:) = 0.0
      NEW_TT(:,:) = 0.0
      NEW_RHS(:) = 0.0
C
C     POPULATING TEMP ARRAYS
      NEW_CC(BC_SLICE) = 1.0
      NEW_CC(MV_SLICE) = CC(:)
      NEW_TT(BC_SLICE, :) = 0.0
      NEW_TT(MV_SLICE, :) = TT(:,:)
      NEW_RHS(BC_SLICE) = BC_VALUE
      NEW_RHS(MV_SLICE) = RHS(:)
C
C     RESIZING OLD ARRAYS
      CALL DEALLOCATE_COEF
      CALL ALLOCATE_COEF(SOLV_NX, SOLV_NZ)
      !
      CC(:) = NEW_CC(:)
      TT(:,:) = NEW_TT(:,:)
      RHS(:) = NEW_RHS(:)
C
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
C ----------------------------------------------------------------------
C
       SUBROUTINE ADD_NUEMANNG_BOUND_COND(SIDE, BC_VALUE)
C
C     WRITTEN BY: MATTHEW STADELMAN
C     DATE WRITTEN: 07/06/2016
C
C     SUBROUTINE DESCRIPTION: SETS A NUEMANN GROUP BOUNDARY CONDITION ON A
C         SPECFIED SIDE. THE NUEMANN_COL AND NUEMANN_ROW VECTORS ARE POPULATED
C         TO CONNECT TO ALL CELLS ON DESIRED SIDE TO A 'GROUP NODE'. THIS
C         BOUNDARY CONDITION TYPE MUST BE ADDED AFTER ALL DIRICHLET
C         CONDITIONS HAVE BEEN ADDED.
C
C     SUBROUTINE CALLS: NONE
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       SIDE - STRING REPRESENTING THE DESIRED SIDE TO ADD THE GROUP NODE
C       BC_VALUE - NUMERIC VALUE OF THE BOUNDARY CONDITION
C       BC_SLICE - STORES THE INDICIES OF CELLS THAT CONNECT TO THE GROUP NODE
C
C ----------------------------------------------------------------------
C
      IMPLICIT NONE
      REAL(8) :: BC_VALUE
      INTEGER, ALLOCATABLE :: BC_SLICE(:)
      INTEGER :: I, IB, ID
      CHARACTER(*) :: SIDE
C
C     DETERMINING INDICIES TO CONNECT TO
      IF (INDEX(SIDE,'BOTTOM') > 0) THEN
        ALLOCATE(BC_SLICE(SOLV_NX))
        ID = 3
        FORALL (IB = 1:SOLV_NX) BC_SLICE(IB) = IB
      ELSE IF (INDEX(SIDE,'TOP') > 0) THEN
        ALLOCATE(BC_SLICE(SOLV_NX))
        ID = 4
        FORALL (IB = 1:SOLV_NX) BC_SLICE(IB) = (SOLV_NZ-1)*SOLV_NX+IB
      ELSE IF (INDEX(SIDE,'LEFT') > 0) THEN
        ALLOCATE(BC_SLICE(SOLV_NZ))
        ID = 1
        FORALL (IB = 0:SOLV_NZ-1) BC_SLICE(IB+1) = IB*SOLV_NX+1
      ELSE IF (INDEX(SIDE,'RIGHT') > 0) THEN
        ALLOCATE(BC_SLICE(SOLV_NZ))
        ID = 2
        FORALL (IB = 0:SOLV_NZ-1) BC_SLICE(IB+1) = IB*SOLV_NX+SOLV_NX
      ELSE
        WRITE(*, 'INVALID BOUNDARY SIDE GIVEN: ' / /SIDE)
        RETURN
      END IF
C
C     SETTING CONNECTIONS TO GROUP NODE AND UPDATING THE TT ARRAY
      NEUMANNG_ROW(:) = 0.0
      NEUMANNG_COL(:) = 0.0
      DO I = 1,SIZE(BC_SLICE)
        IB = BC_SLICE(I)
        NEUMANNG_COL(IB) = TT(IB,ID)
        NEUMANNG_ROW(IB) = TT(IB,ID)
        TT(IB,ID) = 0.0
      END DO
      NEUMANNG_CC = -SUM(NEUMANNG_ROW)
      NEUMANNG_RHS = BC_VALUE
C
      DEALLOCATE(BC_SLICE)
C
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
C ----------------------------------------------------------------------
C
       SUBROUTINE D4_REORDER
C
C     WRITTEN BY: W. NEAL SAMS
C     DATE WRITTEN: 02/29/2016
C
C     SUBROUTINE DESCRIPTION: CREATES ARRAYS TO MAP LEXOGRAPHICAL ORDER TO THE
C         D4 (RED-BLACK) ORDERING SCHEME.
C
C     SUBROUTINE CALLS: NONE
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C
C ----------------------------------------------------------------------
C
      IMPLICIT NONE
      INTEGER :: IBR_MAX(2),IBR,IB,IPASS,IDIAG,I,J
      INTEGER :: ID,JD,IL,IR,IBRU,JBR
C
      ALLOCATE (INAT(SOLV_NX*SOLV_NZ), INO(SOLV_NX*SOLV_NZ))
      ALLOCATE (LINK_D4(SOLV_NX*SOLV_NZ,4))
      FORALL (IB = 1:SOLV_NX*SOLV_NZ) INO(IB) = 0
C
C     REORDER CELL NUMBERING
C
      IBR = 0
      DO IPASS = 1,2
        IF(SOLV_NX >= SOLV_NZ) THEN
          DO IDIAG = IPASS+1,SOLV_NX+SOLV_NZ,2
            DO I = 1,SOLV_NX
              J = IDIAG - I
              IF(J > SOLV_NZ) CYCLE
              IF(J < 1) EXIT
              IB = SOLV_NX*(J-1) + I
              IBR = IBR + 1
              INO(IB) = IBR
            END DO
          END DO
        ELSE
          DO IDIAG = IPASS+1,SOLV_NX+SOLV_NZ,2
            DO J = 1,SOLV_NZ
              I = IDIAG - J
              IF(I > SOLV_NX) CYCLE
              IF(I < 1) EXIT
              IB = SOLV_NX*(J-1) + I
              IBR = IBR + 1
              INO(IB) = IBR
            END DO
          END DO
        END IF
        IBR_MAX(IPASS) = IBR
      END DO
      NUM_TOP = IBR_MAX(1)
      NUM_BOTTOM = IBR_MAX(2) - IBR_MAX(1)
      NUM_TOTAL = IBR_MAX(2)
C
C     SET POINTERS TO ADJACENT CELLS
C
      IB = 0
      DO J = 1,SOLV_NZ
        DO I = 1,SOLV_NX
          IB = IB + 1
          IBR = INO(IB)
          IF(IBR > 0) THEN
            INAT(IBR) = IB
            DO ID = 1,4
              LINK_D4(IBR,ID) = 0
            END DO
            IF(I >  1) LINK_D4(IBR,1) = INO(IB-1)
            IF(I < SOLV_NX) LINK_D4(IBR,2) = INO(IB+1)
            IF(J >  1) LINK_D4(IBR,3) = INO(IB-SOLV_NX)
            IF(J < SOLV_NZ) LINK_D4(IBR,4) = INO(IB+SOLV_NX)
          END IF
        END DO
      END DO
C
C     DETERMINE STORAGE REQUIREMENTS
C
      ALLOCATE (IBASE_UPPER(NUM_TOP+1:NUM_TOTAL+1))
      IR = 0
      MAX_BAND = 0
      IBASE_UPPER(NUM_TOP+1) = 0
      DO IBR = NUM_TOP+1,NUM_TOTAL
        IL = IBR
        DO ID = 1,4
          IBRU = LINK_D4(IBR,ID)
          IF(IBRU > 0) THEN
            DO JD = 1,4
              JBR = LINK_D4(IBRU,JD)
              IF(JBR > 0) THEN
                IF(JBR < IL) IL = JBR
                IF(JBR > IR) IR = JBR
              END IF
            END DO
          END IF
        END DO
        IF(IBR - IL > MAX_BAND) MAX_BAND = IBR - IL
        IF(IR - IBR > MAX_BAND) MAX_BAND = IR - IBR
        IBASE_UPPER(IBR+1) = IBASE_UPPER(IBR) + IR - IBR
      END DO
C
      ALLOCATE (UPPER_D4(IBASE_UPPER(NUM_TOTAL+1)))
C
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
C ----------------------------------------------------------------------
C
      SUBROUTINE D4_SOLVER(X, NEUMANNG_X)
C
C     WRITTEN BY: W. NEAL SAMS
C     DATE WRITTEN: 2016/02/29
C
C     MODIFIED BY: MATTHEW STADELMAN
C     MODFIED ON: 2016/07/08 TO IMPLEMENT NEUMANN GROUP BCs
C     LAST MODIFIED: 2017/02/06
C
C     SUBROUTINE DESCRIPTION: SOLVES THE LINEAR SYSTEM IN D4 ORDER.
C
C     SUBROUTINE CALLS: D4_REORDER, RESET_COEF, DEALLOCATE_COEF
C
C ----------------------------------------------------------------------
C     VARIABLE DESCRIPTION:
C       NG_D4COL - STORES D4 ORDER NUEMANN GROUP NODE COLUMN COEFFICENTS
C       NG_D4ROW - STORES D4 ORDER NUEMANN GROUP NODE ROW COEFFICENTS
C       ROW - STORES THE CURRENT VALUES DURING ELIMINATION OF A ROW
C
C ----------------------------------------------------------------------
C
      IMPLICIT NONE
      REAL(8), ALLOCATABLE :: NG_D4COL(:),NG_D4ROW(:),ROW(:)
      REAL(8), ALLOCATABLE :: TEMP(:),X(:)
      REAL(8) :: TEMP_RHS,TEMP_NGCOL,FACTOR
      REAL(8) :: NEUMANNG_X
      INTEGER :: IBR,IBRU,JBR,IB,IBU,IX,IZ,NXZ
      INTEGER :: ICOL,JCOL,IL,ID,JD,IUP
C
C     REORDING COEFFICENTS FROM LEXOGRAPHICAL TO D4
      CALL D4_REORDER
C
C     SETTING UP ARRAYS
      NXZ = SOLV_NX * SOLV_NZ
      ALLOCATE(NG_D4COL(NXZ), NG_D4ROW(NXZ), TEMP(NXZ), X(NXZ))
      ALLOCATE (ROW(-MAX_BAND:MAX_BAND))

C
C     ELIMINATION ON THE LOWER HALF OF THE MATRIX ROW BY ROW
C
      DO IBR = NUM_TOP+1,NUM_TOTAL
        IB = INAT(IBR) !INAT MAPS D4 ORDER TO LEXI ORDER
        TEMP_RHS = RHS(IB)
        TEMP_NGCOL = NEUMANNG_COL(IB)
C
C     ELIMINATE THE LOWER LEFT QUADRANT OF THE MATRIX AND FILL IN
C     THE LOWER RIGHT QUADRANT OF THE MATRIX.
C
        ROW(:) = 0.0
        ROW(0) = CC(IB)
        IL = 0
        DO ID = 1,4
          IBRU = LINK_D4(IBR,ID)
          IF(IBRU > 0) THEN
            IBU = INAT(IBRU)
            FACTOR = TT(IB,ID)/CC(IBU)
            DO JD = 1,4
              JBR = LINK_D4(IBRU,JD)
              IF(JBR > 0) THEN
                ICOL = JBR - IBR
                IF(ICOL < IL) IL = ICOL
                ROW(ICOL) = ROW(ICOL) - FACTOR*TT(IBU,JD)
              END IF
            END DO
            TEMP_NGCOL = TEMP_NGCOL - FACTOR*NEUMANNG_COL(IBU)
            TEMP_RHS = TEMP_RHS - FACTOR*RHS(IBU)
          END IF
        END DO
C
C     ELIMINATE ELEMENTS TO THE LEFT OF THE DIAGONAL
C
        DO ICOL = IL,-1
          FACTOR = ROW(ICOL)
          JBR = IBR + ICOL
          JCOL = ICOL
          DO IUP = IBASE_UPPER(JBR)+1,IBASE_UPPER(JBR+1)
            JCOL = JCOL + 1
            ROW(JCOL) = ROW(JCOL) - FACTOR*UPPER_D4(IUP)
          END DO
          TEMP_NGCOL = TEMP_NGCOL - FACTOR*NG_D4COL(JBR)
          TEMP_RHS = TEMP_RHS - FACTOR*X(INAT(JBR))
        END DO
C
C     NORMALIZE AND STORE UPPER TRIANGLE
C
        FACTOR = 1.0/ROW(0)
        ICOL = 0
        DO IUP = IBASE_UPPER(IBR)+1,IBASE_UPPER(IBR+1)
          ICOL = ICOL + 1
          UPPER_D4(IUP) = FACTOR*ROW(ICOL)
        END DO
        NG_D4COL(IBR) = FACTOR*TEMP_NGCOL
        X(IB) = FACTOR*TEMP_RHS
      END DO
C
C     ELIMINATING THE NEUMANN GROUP ROW
C
      FORALL (IB = 1:NXZ) NG_D4ROW(INO(IB)) = NEUMANNG_ROW(IB)
      ! HANDLING UPPER HALF
      DO IBR = 1,NUM_TOP
        IB = INAT(IBR)
        !
        FACTOR = NG_D4ROW(IBR)/CC(IB)
        DO JD = 1,4
          JBR = LINK_D4(IBR,JD)
          IF(JBR > 0) THEN
            NG_D4ROW(JBR) = NG_D4ROW(JBR) - FACTOR*TT(IB,JD)
          END IF
        END DO
        NEUMANNG_CC = NEUMANNG_CC - FACTOR*NEUMANNG_COL(IB)
        NEUMANNG_RHS = NEUMANNG_RHS - FACTOR*RHS(IB)
      END DO
! HANDLING LOWER HALF
      DO IBR = NUM_TOP+1,NUM_TOTAL
        FACTOR = NG_D4ROW(IBR)
        JCOL = IBR
        DO IUP = IBASE_UPPER(IBR)+1,IBASE_UPPER(IBR+1)
          JCOL = JCOL + 1
          NG_D4ROW(JCOL) = NG_D4ROW(JCOL)-FACTOR*UPPER_D4(IUP)
        END DO
        NEUMANNG_CC = NEUMANNG_CC - FACTOR*NG_D4COL(IBR)
        NEUMANNG_RHS = NEUMANNG_RHS - FACTOR*X(INAT(IBR))
      END DO
      NEUMANNG_X = NEUMANNG_RHS/NEUMANNG_CC
C
C     BACK SUBSTITUTION ON LOWER HALF
C
      X(INAT(NXZ)) = X(INAT(NXZ)) - NG_D4COL(NXZ)*NEUMANNG_X
      DO IBR = NUM_TOTAL-1,NUM_TOP+1,-1
        IB = INAT(IBR)
        TEMP_RHS = X(IB)
        TEMP_RHS = TEMP_RHS - NG_D4COL(IBR)*NEUMANNG_X
        JBR = IBR
        DO IUP = IBASE_UPPER(IBR)+1,IBASE_UPPER(IBR+1)
          JBR = JBR + 1
          TEMP_RHS = TEMP_RHS - UPPER_D4(IUP)*X(INAT(JBR))
        END DO
        X(IB) = TEMP_RHS
      END DO
C
C     BACK SUBSTITUTION ON UPPER HALF
C
      DO IBR = 1,NUM_TOP
        IB = INAT(IBR)
        TEMP_RHS = RHS(IB)
        TEMP_RHS = TEMP_RHS - NEUMANNG_COL(IB)*NEUMANNG_X
        DO ID = 1,4
          JBR = LINK_D4(IBR,ID)
          IF(JBR > 0) TEMP_RHS = TEMP_RHS - TT(IB,ID)*X(INAT(JBR))
        END DO
        X(IB) = TEMP_RHS/CC(IB)
      END DO
C
C     ADJUSTING X VECTOR TO MATCH ORIGINAL MATRIX SIZE
      TEMP(:) = X(:)
      DEALLOCATE(X)
      ALLOCATE(X(ORIG_NX * ORIG_NZ))
      DO IZ = 1, ORIG_NZ
        DO IX = 1, ORIG_NX
          IBU = (IZ + Z_OFFSET - 1)*SOLV_NX + IX + X_OFFSET
          IB = (IZ - 1)*ORIG_NX + IX
          X(IB) = TEMP(IBU)
        END DO
      END DO
C
      CALL RESET_COEF
      CALL DEALLOCATE_COEF
      DEALLOCATE(NG_D4COL, NG_D4ROW, ROW, TEMP)
      DEALLOCATE(UPPER_D4, LINK_D4, INO, INAT, IBASE_UPPER)
C
      RETURN
      END SUBROUTINE
C
C ----------------------------------------------------------------------
C @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
C ----------------------------------------------------------------------
C
      END MODULE
